<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>md/writing-motoko/errors.md</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">md/writing-motoko/errors.md</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#error-handling" id="toc-error-handling">Error handling</a>
<ul>
<li><a href="#overview" id="toc-overview">Overview</a></li>
<li><a href="#example" id="toc-example">Example</a></li>
<li><a href="#optionresult" id="toc-optionresult">Option/result</a>
<ul>
<li><a href="#error-reporting-with-option-types"
id="toc-error-reporting-with-option-types">Error reporting with
<code>Option</code> types</a></li>
<li><a href="#error-reporting-with-result-types"
id="toc-error-reporting-with-result-types">Error reporting with
<code>Result</code> types</a></li>
<li><a href="#pattern-matching" id="toc-pattern-matching">Pattern
matching</a></li>
<li><a href="#higher-order-functions"
id="toc-higher-order-functions">Higher-order functions</a></li>
</ul></li>
<li><a href="#asynchronous-errors"
id="toc-asynchronous-errors">Asynchronous errors</a></li>
<li><a href="#using-tryfinally" id="toc-using-tryfinally">Using
try/finally</a>
<ul>
<li><a href="#how-not-to-handle-errors"
id="toc-how-not-to-handle-errors">How not to handle errors</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="error-handling">Error handling</h1>
<h2 id="overview">Overview</h2>
<p>There are three primary ways to represent and handle errors values in
Motoko:</p>
<ul>
<li><p>Option values with a non-informative <code>null</code> value that
indicates some error.</p></li>
<li><p><code>Result</code> variants with a descriptive
<code>#err value</code> providing more information about the
error.</p></li>
<li><p><a href="../base/Error.md"><code>Error</code></a> values that, in
an asynchronous context, can be thrown and caught similar to exceptions
and contain a numeric code and message.</p></li>
</ul>
<h2 id="example">Example</h2>
<p>Consider building an API for a to-do application that wants to expose
a function allowing users to mark one of their tasks’s as "Done". This
simple example will accept a <code>TodoId</code> object and return an <a
href="../base/Int.md"><code>Int</code></a> that represents how many
seconds the to-do has been open. This example assumes that it is running
in an actor, which returns an async value:</p>
<pre class="motoko"><code>func markDone(id : TodoId) : async Int</code></pre>
<p>The full application example can be found below:</p>
<pre class="motoko"><code></code></pre>
<pre class="motoko"><code></code></pre>
<p>In this example, there are conditions under which marking a to-do as
"Done" fails:</p>
<ul>
<li><p>The <code>id</code> could reference a non-existing
to-do.</p></li>
<li><p>The to-do might already be marked as done.</p></li>
</ul>
<p>Let's look at the different ways to communicate these errors in
Motoko and slowly improve the example API.</p>
<h2 id="optionresult">Option/result</h2>
<p>Using <code>Option</code> or <code>Result</code> is the preferred way
of signaling errors in Motoko. They work in both synchronous and
asynchronous contexts and make your APIs safer to use by encouraging
clients to consider the error cases as well as the success cases.
Exceptions should only be used to signal unexpected error states.</p>
<h3 id="error-reporting-with-option-types">Error reporting with
<code>Option</code> types</h3>
<p>A function that wants to return a value of type <code>A</code> or
signal an error can return a value of option type <code>?A</code> and
use the <code>null</code> value to designate the error. In the above
example this means the <code>markDone</code> function returns an
<code>async ?Seconds</code>:</p>
<p>Definition:</p>
<pre class="motoko"><code></code></pre>
<p>Callsite:</p>
<pre class="motoko"><code></code></pre>
<p>The main drawback of this approach is that it conflates all possible
errors with a single, non-informative <code>null</code> value. The
callsite might be interested in why marking a <code>Todo</code> as done
has failed, but that information is lost by then, which means we can
only tell the user that <code>"Something went wrong."</code>.</p>
<p>Returning option values to signal errors should only be used if there
just one possible reason for the failure and that reason can be easily
determined at the callsite. One example of a good use case for this is a
HashMap lookup failing.</p>
<h3 id="error-reporting-with-result-types">Error reporting with
<code>Result</code> types</h3>
<p>While options are a built-in type, the <code>Result</code> is defined
as a variant type like so:</p>
<pre class="motoko"><code>type Result&lt;Ok, Err&gt; = { #ok : Ok; #err : Err }</code></pre>
<p>Because of the second type parameter, <code>Err</code>, the
<code>Result</code> type lets you select the type used to describe
errors. Define a <code>TodoError</code> type that the
<code>markDone</code> function will use to signal errors:</p>
<pre class="motoko"><code></code></pre>
<p>The original example is now revised as:</p>
<p>Definition:</p>
<pre class="motoko"><code></code></pre>
<p>Callsite:</p>
<pre class="motoko"><code></code></pre>
<h3 id="pattern-matching">Pattern matching</h3>
<p>The first and most common way of working with <code>Option</code> and
<code>Result</code> is to use pattern matching. If you have a value of
type <code>?Text</code>, you can use the <code>switch</code> keyword to
access the potential <a href="../base/Text.md"><code>Text</code></a>
contents:</p>
<pre class="motoko"><code></code></pre>
<p>Motoko does not let you access the optional value without also
considering the case that it is missing.</p>
<p>In the case of a <code>Result</code>, you can also use pattern
matching with the difference that you also get an informative value, not
just <code>null</code>, in the <code>#err</code> case:</p>
<pre class="motoko"><code></code></pre>
<h3 id="higher-order-functions">Higher-order functions</h3>
<p>Pattern matching can become tedious and verbose, especially when
dealing with multiple optional values. The <a
href="https://github.com/dfinity/motoko-base">base</a> library exposes a
collection of higher-order functions from the <code>Option</code> and
<code>Result</code> modules to improve the ergonomics of error
handling.</p>
<p>Sometimes you’ll want to move between <code>Option</code> and
<code>Result</code>. A Hashmap lookup returns <code>null</code> on
failure, but maybe the caller has more context and can turn that lookup
failure into a meaningful <code>Result</code>. Other times you don’t
need the additional information a <code>Result</code> provides and just
want to convert all <code>#err</code> cases into <code>null</code>. For
these situations <a
href="https://github.com/dfinity/motoko-base">base</a> provides the
<code>fromOption</code> and <code>toOption</code> functions in the
<code>Result</code> module.</p>
<h2 id="asynchronous-errors">Asynchronous errors</h2>
<p>The last way of dealing with errors in Motoko is to use asynchronous
<a href="../base/Error.md"><code>Error</code></a> handling, a restricted
form of the exception handling familiar from other languages. Motoko
error values can only be thrown and caught in asynchronous contexts,
typically the body of a <code>shared</code> function or
<code>async</code> expression. Non-<code>shared</code> functions cannot
employ structured error handling. This means you can exit a shared
function by <code>throw</code>ing an <a
href="../base/Error.md"><code>Error</code></a> value and
<code>try</code> some code calling a shared function on another actor.
In this workflow, you can <code>catch</code> the failure as a result of
type <a href="../base/Error.md"><code>Error</code></a>, but you can’t
use these error handling constructs outside of an asynchronous
context.</p>
<p>Asynchronous <a href="../base/Error.md"><code>Error</code></a>s
should generally only be used to signal unexpected failures that you
cannot recover from and that you don’t expect many consumers of your API
to handle. If a failure should be handled by your caller, you should
make it explicit in your signature by returning a <code>Result</code>
instead. For completeness, here is the <code>markDone</code> example
with exceptions:</p>
<p>Definition:</p>
<pre class="motoko"><code></code></pre>
<p>Callsite:</p>
<pre class="motoko"><code></code></pre>
<h2 id="using-tryfinally">Using try/finally</h2>
<p>A <code>finally</code> clause can be used within a
<code>try/catch</code> error handling expression that facilitates
control-flow expression cleanups, resource deallocation, or rolling back
temporary state changes. The <code>finally</code> clause is optional,
and when used, the <code>catch</code> clause may be omitted. Any
uncaught error from the <code>try</code> block will be propagated after
the <code>finally</code> block has executed.</p>
<p>:::info</p>
<p><code>try/finally</code> is supported in <code>moc</code>
<code>v0.12.0</code> and newer, and <code>dfx</code>
<code>v0.24.0</code> and newer.</p>
<p>:::</p>
<p><code>try/finally</code> must be used within an async expression or
in the body of a shared function. Before using <code>try/finally</code>,
please review the <a
href="https://internetcomputer.org/docs/current/developer-docs/security/security-best-practices/inter-canister-calls#recommendation">security
best practices</a> for using this syntax.</p>
<pre class="motoko"><code></code></pre>
<p>Inside the <code>try</code> block, include code that may throw an
error. In the <code>finally</code> block, include code that should be
executed whether an error was thrown or not. Code within the
<code>finally</code> block should not trap and should terminate
promptly. If a <code>finally</code> block were to trap, it may prevent a
future upgrade to the canister.</p>
<p>Learn more about <a
href="https://internetcomputer.org/docs/current/motoko/main/reference/language-manual#try"><code>try/finally</code></a>.</p>
<h3 id="how-not-to-handle-errors">How not to handle errors</h3>
<p>A generally poor way of reporting errors is through the use of a
sentinel value. For example, for your <code>markDone</code> function,
you might decide to use the value <code>-1</code> to signal that
something failed. The callsite then has to check the return value
against this special value and report the error. It's easy to not check
for that error condition and continue to work with that value in the
code. This can lead to delayed or even missing error detection and is
strongly discouraged.</p>
<p>Definition:</p>
<pre class="motoko"><code></code></pre>
<p>Callsite:</p>
<pre class="motoko"><code></code></pre>
<img src="https://github.com/user-attachments/assets/844ca364-4d71-42b3-aaec-4a6c3509ee2e" alt="Logo" width="150" height="150" />
</body>
</html>
