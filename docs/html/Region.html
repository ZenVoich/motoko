<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>md/base/Region.md</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">md/base/Region.md</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#region" id="toc-region">Region</a>
<ul>
<li><a href="#type-region" id="toc-type-region">Type
<code>Region</code></a></li>
<li><a href="#value-new" id="toc-value-new">Value
<code>new</code></a></li>
<li><a href="#value-id" id="toc-value-id">Value <code>id</code></a></li>
<li><a href="#value-size" id="toc-value-size">Value
<code>size</code></a></li>
<li><a href="#value-grow" id="toc-value-grow">Value
<code>grow</code></a></li>
<li><a href="#value-loadnat8" id="toc-value-loadnat8">Value
<code>loadNat8</code></a></li>
<li><a href="#value-storenat8" id="toc-value-storenat8">Value
<code>storeNat8</code></a></li>
<li><a href="#value-loadnat16" id="toc-value-loadnat16">Value
<code>loadNat16</code></a></li>
<li><a href="#value-storenat16" id="toc-value-storenat16">Value
<code>storeNat16</code></a></li>
<li><a href="#value-loadnat32" id="toc-value-loadnat32">Value
<code>loadNat32</code></a></li>
<li><a href="#value-storenat32" id="toc-value-storenat32">Value
<code>storeNat32</code></a></li>
<li><a href="#value-loadnat64" id="toc-value-loadnat64">Value
<code>loadNat64</code></a></li>
<li><a href="#value-storenat64" id="toc-value-storenat64">Value
<code>storeNat64</code></a></li>
<li><a href="#value-loadint8" id="toc-value-loadint8">Value
<code>loadInt8</code></a></li>
<li><a href="#value-storeint8" id="toc-value-storeint8">Value
<code>storeInt8</code></a></li>
<li><a href="#value-loadint16" id="toc-value-loadint16">Value
<code>loadInt16</code></a></li>
<li><a href="#value-storeint16" id="toc-value-storeint16">Value
<code>storeInt16</code></a></li>
<li><a href="#value-loadint32" id="toc-value-loadint32">Value
<code>loadInt32</code></a></li>
<li><a href="#value-storeint32" id="toc-value-storeint32">Value
<code>storeInt32</code></a></li>
<li><a href="#value-loadint64" id="toc-value-loadint64">Value
<code>loadInt64</code></a></li>
<li><a href="#value-storeint64" id="toc-value-storeint64">Value
<code>storeInt64</code></a></li>
<li><a href="#value-loadfloat" id="toc-value-loadfloat">Value
<code>loadFloat</code></a></li>
<li><a href="#value-storefloat" id="toc-value-storefloat">Value
<code>storeFloat</code></a></li>
<li><a href="#value-loadblob" id="toc-value-loadblob">Value
<code>loadBlob</code></a></li>
<li><a href="#value-storeblob" id="toc-value-storeblob">Value
<code>storeBlob</code></a></li>
</ul></li>
</ul>
</nav>
<h1 id="region">Region</h1>
<p>Byte-level access to isolated, (virtual) stable memory
<em>regions</em>.</p>
<p>This is a moderately lightweight abstraction over IC <em>stable
memory</em> and supports persisting regions of binary data across Motoko
upgrades. Use of this module is fully compatible with Motoko's use of
<em>stable variables</em>, whose persistence mechanism also uses (real)
IC stable memory internally, but does not interfere with this API. It is
also fully compatible with existing uses of the
<code>ExperimentalStableMemory</code> library, which has a similar
interface, but, only supported a single memory region, without isolation
between different applications.</p>
<p>The <code>Region</code> type is stable and can be used in stable data
structures.</p>
<p>A new, empty <code>Region</code> is allocated using function
<code>new()</code>.</p>
<p>Regions are stateful objects and can be distinguished by the numeric
identifier returned by function <code>id(region)</code>. Every region
owns an initially empty, but growable sequence of virtual IC stable
memory pages. The current size, in pages, of a region is returned by
function <code>size(region)</code>. The size of a region determines the
range, [ 0, ..., size(region)*2^16 ), of valid byte-offsets into the
region; these offsets are used as the source and destination of
<code>load</code>/<code>store</code> operations on the region.</p>
<p>Memory is allocated to a region, using function
<code>grow(region, pages)</code>, sequentially and on demand, in units
of 64KiB logical pages, starting with 0 allocated pages. A call to
<code>grow</code> may succeed, returning the previous size of the
region, or fail, returning a sentinel value. New pages are zero
initialized.</p>
<p>A size of a region can only grow and never shrink. In addition, the
stable memory pages allocated to a region will <em>not</em> be reclaimed
by garbage collection, even if the region object itself becomes
unreachable.</p>
<p>Growth is capped by a soft limit on physical page count controlled by
compile-time flag <code>--max-stable-pages &lt;n&gt;</code> (the default
is 65536, or 4GiB).</p>
<p>Each <code>load</code> operation loads from region relative byte
address <code>offset</code> in little-endian format using the natural
bit-width of the type in question. The operation traps if attempting to
read beyond the current region size.</p>
<p>Each <code>store</code> operation stores to region relative byte
address <code>offset</code> in little-endian format using the natural
bit-width of the type in question. The operation traps if attempting to
write beyond the current region size.</p>
<p>Text values can be handled by using <code>Text.decodeUtf8</code> and
<code>Text.encodeUtf8</code>, in conjunction with <code>loadBlob</code>
and <code>storeBlob</code>.</p>
<p>The current region allocation and region contents are preserved
across upgrades.</p>
<p>NB: The IC's actual stable memory size (<code>ic0.stable_size</code>)
may exceed the total page size reported by summing all regions sizes.
This (and the cap on growth) are to accommodate Motoko's stable
variables and bookkeeping for regions. Applications that plan to use
Motoko stable variables sparingly or not at all can increase
<code>--max-stable-pages</code> as desired, approaching the IC maximum
(initially 8GiB, then 32Gib, currently 64Gib). All applications should
reserve at least one page for stable variable data, even when no stable
variables are used.</p>
<p>Usage:</p>
<pre class="motoko"><code>import Region &quot;mo:base/Region&quot;;</code></pre>
<h2 id="type-region">Type <code>Region</code></h2>
<pre class="motoko"><code>type Region = Prim.Types.Region</code></pre>
<p>A stateful handle to an isolated region of IC stable memory.
<code>Region</code> is a stable type and regions can be stored in stable
variables.</p>
<h2 id="value-new">Value <code>new</code></h2>
<pre class="motoko"><code>let new : () -&gt; Region</code></pre>
<p>Allocate a new, isolated Region of size 0.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
assert Region.size(region) == 0;</code></pre>
<h2 id="value-id">Value <code>id</code></h2>
<pre class="motoko"><code>let id : Region -&gt; Nat</code></pre>
<p>Return a Nat identifying the given region. Maybe be used for
equality, comparison and hashing. NB: Regions returned by
<code>new()</code> are numbered from 16 (regions 0..15 are currently
reserved for internal use). Allocate a new, isolated Region of size
0.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
assert Region.id(region) == 16;</code></pre>
<h2 id="value-size">Value <code>size</code></h2>
<pre class="motoko"><code>let size : (region : Region) -&gt; (pages : Nat64)</code></pre>
<p>Current size of <code>region</code>, in pages. Each page is 64KiB
(65536 bytes). Initially <code>0</code>. Preserved across upgrades,
together with contents of allocated stable memory.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let beforeSize = Region.size(region);
ignore Region.grow(region, 10);
let afterSize = Region.size(region);
afterSize - beforeSize // =&gt; 10</code></pre>
<h2 id="value-grow">Value <code>grow</code></h2>
<pre class="motoko"><code>let grow : (region : Region, newPages : Nat64) -&gt; (oldPages : Nat64)</code></pre>
<p>Grow current <code>size</code> of <code>region</code> by the given
number of pages. Each page is 64KiB (65536 bytes). Returns the previous
<code>size</code> when able to grow. Returns
<code>0xFFFF_FFFF_FFFF_FFFF</code> if remaining pages insufficient.
Every new page is zero-initialized, containing byte 0x00 at every
offset. Function <code>grow</code> is capped by a soft limit on
<code>size</code> controlled by compile-time flag
<code>--max-stable-pages &lt;n&gt;</code> (the default is 65536, or
4GiB).</p>
<p>Example:</p>
<pre class="motoko"><code>import Error &quot;mo:base/Error&quot;;

let region = Region.new();
let beforeSize = Region.grow(region, 10);
if (beforeSize == 0xFFFF_FFFF_FFFF_FFFF) {
  throw Error.reject(&quot;Out of memory&quot;);
};
let afterSize = Region.size(region);
afterSize - beforeSize // =&gt; 10</code></pre>
<h2 id="value-loadnat8">Value <code>loadNat8</code></h2>
<pre class="motoko"><code>let loadNat8 : (region : Region, offset : Nat64) -&gt; Nat8</code></pre>
<p>Within <code>region</code>, load a <code>Nat8</code> value from
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 123;
Region.storeNat8(region, offset, value);
Region.loadNat8(region, offset) // =&gt; 123</code></pre>
<h2 id="value-storenat8">Value <code>storeNat8</code></h2>
<pre class="motoko"><code>let storeNat8 : (region : Region, offset : Nat64, value : Nat8) -&gt; ()</code></pre>
<p>Within <code>region</code>, store a <code>Nat8</code> value at
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 123;
Region.storeNat8(region, offset, value);
Region.loadNat8(region, offset) // =&gt; 123</code></pre>
<h2 id="value-loadnat16">Value <code>loadNat16</code></h2>
<pre class="motoko"><code>let loadNat16 : (region : Region, offset : Nat64) -&gt; Nat16</code></pre>
<p>Within <code>region</code>, load a <code>Nat16</code> value from
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 123;
Region.storeNat16(region, offset, value);
Region.loadNat16(region, offset) // =&gt; 123</code></pre>
<h2 id="value-storenat16">Value <code>storeNat16</code></h2>
<pre class="motoko"><code>let storeNat16 : (region : Region, offset : Nat64, value : Nat16) -&gt; ()</code></pre>
<p>Within <code>region</code>, store a <code>Nat16</code> value at
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 123;
Region.storeNat16(region, offset, value);
Region.loadNat16(region, offset) // =&gt; 123</code></pre>
<h2 id="value-loadnat32">Value <code>loadNat32</code></h2>
<pre class="motoko"><code>let loadNat32 : (region : Region, offset : Nat64) -&gt; Nat32</code></pre>
<p>Within <code>region</code>, load a <code>Nat32</code> value from
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 123;
Region.storeNat32(region, offset, value);
Region.loadNat32(region, offset) // =&gt; 123</code></pre>
<h2 id="value-storenat32">Value <code>storeNat32</code></h2>
<pre class="motoko"><code>let storeNat32 : (region : Region, offset : Nat64, value : Nat32) -&gt; ()</code></pre>
<p>Within <code>region</code>, store a <code>Nat32</code> value at
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 123;
Region.storeNat32(region, offset, value);
Region.loadNat32(region, offset) // =&gt; 123</code></pre>
<h2 id="value-loadnat64">Value <code>loadNat64</code></h2>
<pre class="motoko"><code>let loadNat64 : (region : Region, offset : Nat64) -&gt; Nat64</code></pre>
<p>Within <code>region</code>, load a <code>Nat64</code> value from
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 123;
Region.storeNat64(region, offset, value);
Region.loadNat64(region, offset) // =&gt; 123</code></pre>
<h2 id="value-storenat64">Value <code>storeNat64</code></h2>
<pre class="motoko"><code>let storeNat64 : (region : Region, offset : Nat64, value : Nat64) -&gt; ()</code></pre>
<p>Within <code>region</code>, store a <code>Nat64</code> value at
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 123;
Region.storeNat64(region, offset, value);
Region.loadNat64(region, offset) // =&gt; 123</code></pre>
<h2 id="value-loadint8">Value <code>loadInt8</code></h2>
<pre class="motoko"><code>let loadInt8 : (region : Region, offset : Nat64) -&gt; Int8</code></pre>
<p>Within <code>region</code>, load a <code>Int8</code> value from
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 123;
Region.storeInt8(region, offset, value);
Region.loadInt8(region, offset) // =&gt; 123</code></pre>
<h2 id="value-storeint8">Value <code>storeInt8</code></h2>
<pre class="motoko"><code>let storeInt8 : (region : Region, offset : Nat64, value : Int8) -&gt; ()</code></pre>
<p>Within <code>region</code>, store a <code>Int8</code> value at
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 123;
Region.storeInt8(region, offset, value);
Region.loadInt8(region, offset) // =&gt; 123</code></pre>
<h2 id="value-loadint16">Value <code>loadInt16</code></h2>
<pre class="motoko"><code>let loadInt16 : (region : Region, offset : Nat64) -&gt; Int16</code></pre>
<p>Within <code>region</code>, load a <code>Int16</code> value from
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 123;
Region.storeInt16(region, offset, value);
Region.loadInt16(region, offset) // =&gt; 123</code></pre>
<h2 id="value-storeint16">Value <code>storeInt16</code></h2>
<pre class="motoko"><code>let storeInt16 : (region : Region, offset : Nat64, value : Int16) -&gt; ()</code></pre>
<p>Within <code>region</code>, store a <code>Int16</code> value at
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 123;
Region.storeInt16(region, offset, value);
Region.loadInt16(region, offset) // =&gt; 123</code></pre>
<h2 id="value-loadint32">Value <code>loadInt32</code></h2>
<pre class="motoko"><code>let loadInt32 : (region : Region, offset : Nat64) -&gt; Int32</code></pre>
<p>Within <code>region</code>, load a <code>Int32</code> value from
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 123;
Region.storeInt32(region, offset, value);
Region.loadInt32(region, offset) // =&gt; 123</code></pre>
<h2 id="value-storeint32">Value <code>storeInt32</code></h2>
<pre class="motoko"><code>let storeInt32 : (region : Region, offset : Nat64, value : Int32) -&gt; ()</code></pre>
<p>Within <code>region</code>, store a <code>Int32</code> value at
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 123;
Region.storeInt32(region, offset, value);
Region.loadInt32(region, offset) // =&gt; 123</code></pre>
<h2 id="value-loadint64">Value <code>loadInt64</code></h2>
<pre class="motoko"><code>let loadInt64 : (region : Region, offset : Nat64) -&gt; Int64</code></pre>
<p>Within <code>region</code>, load a <code>Int64</code> value from
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 123;
Region.storeInt64(region, offset, value);
Region.loadInt64(region, offset) // =&gt; 123</code></pre>
<h2 id="value-storeint64">Value <code>storeInt64</code></h2>
<pre class="motoko"><code>let storeInt64 : (region : Region, offset : Nat64, value : Int64) -&gt; ()</code></pre>
<p>Within <code>region</code>, store a <code>Int64</code> value at
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 123;
Region.storeInt64(region, offset, value);
Region.loadInt64(region, offset) // =&gt; 123</code></pre>
<h2 id="value-loadfloat">Value <code>loadFloat</code></h2>
<pre class="motoko"><code>let loadFloat : (region : Region, offset : Nat64) -&gt; Float</code></pre>
<p>Within <code>region</code>, loads a <code>Float</code> value from the
given <code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 1.25;
Region.storeFloat(region, offset, value);
Region.loadFloat(region, offset) // =&gt; 1.25</code></pre>
<h2 id="value-storefloat">Value <code>storeFloat</code></h2>
<pre class="motoko"><code>let storeFloat : (region : Region, offset : Nat64, value : Float) -&gt; ()</code></pre>
<p>Within <code>region</code>, store float <code>value</code> at the
given <code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let region = Region.new();
let offset = 0;
let value = 1.25;
Region.storeFloat(region, offset, value);
Region.loadFloat(region, offset) // =&gt; 1.25</code></pre>
<h2 id="value-loadblob">Value <code>loadBlob</code></h2>
<pre class="motoko"><code>let loadBlob : (region : Region, offset : Nat64, size : Nat) -&gt; Blob</code></pre>
<p>Within <code>region,</code> load <code>size</code> bytes starting
from <code>offset</code> as a <code>Blob</code>. Traps on an
out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>import Blob &quot;mo:base/Blob&quot;;

let region = Region.new();
let offset = 0;
let value = Blob.fromArray([1, 2, 3]);
let size = value.size();
Region.storeBlob(region, offset, value);
Blob.toArray(Region.loadBlob(region, offset, size)) // =&gt; [1, 2, 3]</code></pre>
<h2 id="value-storeblob">Value <code>storeBlob</code></h2>
<pre class="motoko"><code>let storeBlob : (region : Region, offset : Nat64, value : Blob) -&gt; ()</code></pre>
<p>Within
<code>region, write </code>blob.size()<code>bytes of</code>blob<code>beginning at</code>offset`.
Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>import Blob &quot;mo:base/Blob&quot;;

let region = Region.new();
let offset = 0;
let value = Blob.fromArray([1, 2, 3]);
let size = value.size();
Region.storeBlob(region, offset, value);
Blob.toArray(Region.loadBlob(region, offset, size)) // =&gt; [1, 2, 3]</code></pre>
</body>
</html>
