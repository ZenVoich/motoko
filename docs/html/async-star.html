<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>md/writing-motoko/async-star.md</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">md/writing-motoko/async-star.md</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#abstracting-asynchronous-code"
id="toc-abstracting-asynchronous-code">Abstracting asynchronous code</a>
<ul>
<li><a href="#overview" id="toc-overview">Overview</a></li>
<li><a href="#computation-types" id="toc-computation-types">Computation
types</a></li>
<li><a href="#mops-packages-for-computations"
id="toc-mops-packages-for-computations">Mops packages for
computations</a></li>
</ul></li>
</ul>
</nav>
<h1 id="abstracting-asynchronous-code">Abstracting asynchronous
code</h1>
<h2 id="overview">Overview</h2>
<p>Functions are an abstraction mechanism, allowing you to name a
computation and re-use that computation in different locations within
your code simply by invoking the name of that function. When the
function takes parameters, you can tailor the computation to different
call sites by providing different arguments.</p>
<p>Programmers often improve their code by re-factoring common patterns
of code into a single, reusable function.</p>
<p>In Motoko, you might want to refactor code that involves asynchronous
operations such as sending messages or awaiting futures. Motoko's type
system prevents you from using an ordinary function for this because
ordinary functions are not allowed to send messages nor await. You can,
however, define a local, asynchronous function containing the
asynchronous code, and then replace all occurrences of the pattern by a
call to that function. Since these calls return futures, each call must
be enclosed in an <code>await</code> to extract its future's result.</p>
<p>Though this can work, it has some overhead and pitfalls:</p>
<ul>
<li><p>Each call of the function involves sending an additional message
to the actor itself.</p></li>
<li><p>Every call must be awaited, significantly adding to the cost of
the code it abstracts.</p></li>
<li><p>Each await involves suspending the execution of the awaiter until
a reply is available, allowing more interleavings, and thus more
interference, with the execution of other concurrent messages.</p></li>
</ul>
<p>Consider the following code that does some logging to a remote
canister.</p>
<pre class="motoko"><code>actor class (Logger : actor { log : Text -&gt; async () }) {

  var logging = true;

  func doStuff() : async () {
    // do stuff
    if (logging) { await Logger.log(&quot;stuff&quot;) };
    // do more stuff
    if (logging) { await Logger.log(&quot;more stuff&quot;) };
  }
}</code></pre>
<p>To avoid repetition of the logging logic, it would be nice to
refactor this code to use a helper function <code>maybeLog</code>. The
<code>maybeLog</code> function needs to be asynchronous because
communicating with the <code>Logger</code> canister involves sending a
message.</p>
<pre class="motoko"><code>actor class (Logger : actor { log : Text -&gt; async () }) {

  var logging = true;

  func maybeLog(msg : Text) : async () {
    if (logging) { await Logger.log(msg) };
  };

  func doStuff() : async () {
    // do stuff
    await maybeLog(&quot;stuff&quot;);
    // do more stuff
    await maybeLog(&quot;more stuff&quot;);
  }
}</code></pre>
<p>While this typechecks and runs, the code for <code>doStuff()</code>
is now much less efficient than the original code, since each call to
<code>maybeLog</code> function involves an additional <code>await</code>
that suspends the execution of <code>doStuff()</code>, even when the
<code>logging</code> flag is <code>false</code>. The semantics of this
code is also slightly different, since the value of the logging variable
could, in principle, change between the call to <code>maybeLog</code>
and the execution of its body, depending on the rest of the actor
code.</p>
<p>A safer refactoring passes the current state of the
<code>logging</code> variable with each call:</p>
<pre class="motoko"><code>actor class (Logger : actor { log : Text -&gt; async () }) {

  var logging = true;

  func maybeLog(log : Bool, msg : Text) : async () {
    if (log) { await Logger.log(msg) };
  };

  func doStuff() : async () {
    // do stuff
    await maybeLog(logging, &quot;stuff&quot;);
    // do more stuff
    await maybeLog(logging, &quot;more stuff&quot;);
  }
}</code></pre>
<h2 id="computation-types">Computation types</h2>
<p>To avoid the overhead and dangers of additional awaits, Motoko offers
computation types, <code>async* T</code>, that, like future types,
<code>async T</code>, can abstract asynchronous tasks.</p>
<p>Just as an <code>async</code> expression is used to create a future
(by scheduling the execution of its body), an <code>async*</code>
expression is used to create a computation (by delaying the execution of
its body). Similar to how <code>await</code> is used to consume the
result of a future, <code>await*</code> is used to produce the result of
a computation (by demanding another execution of its body).</p>
<p>From a typing perspective, futures and computations are very similar.
Where they differ is in their dynamic behavior: a future is a stateful
object that holds the result of a scheduled, asynchronous task while a
computation is just an inert value describing a task.</p>
<p>Unlike <code>await</code> on a future, <code>await*</code> on a
computation does not suspend the awaiter, it just immediately executes
the computation much like an ordinary function call. This means that
awaiting an <code>async*</code> value only suspends its execution (to
complete asynchronously), if the body of the <code>async*</code> does a
proper <code>await</code>. The <code>*</code> on these expressions is
meant to indicate that the computation may involve 0 or more ordinary
<code>await</code> expressions, and thus may be interleaved with the
execution of other messages.</p>
<p>To create an <code>async*</code> value, you can just use an
<code>async*</code> expression, but more typically, you'll declare a
local function that returns an <code>async*</code> type.</p>
<p>To compute the result of an <code>async*</code> computation, you just
use an <code>await*</code>.</p>
<p>Here's how we can refactor our original class to be clearer,
efficient and have the same meaning, using computations instead of
futures:</p>
<pre class="motoko"><code>actor class (Logger : actor { log : Text -&gt; async () }) {

  var logging = true;

  func maybeLog(msg : Text) : async* () {
    if (logging) { await Logger.log(msg) };
  };

  func doStuff() : async () {
    // do stuff
    await* maybeLog(&quot;stuff&quot;);
    // do more stuff
    await* maybeLog(&quot;more stuff&quot;);
  }
}</code></pre>
<p>One notable difference between <code>async</code> and
<code>async*</code> expressions is that the former are eager, while the
latter are not. This means that calling the async version of
<code>maybeLog</code> will eagerly schedule its body to run, even if the
<code>async</code> result (a future) of the call is never
<code>await</code>ed. Awaiting the same future another time will always
produce the original result: the message is executed just once.</p>
<p>On the other hand, calling the <code>async*</code> version of
<code>maybeLog</code> will do nothing unless the result is
<code>await*</code>-ed, and <code>await*</code>-ing the same computation
several times will repeat the computation each time.</p>
<p>For another example, suppose we define a clap function with the
side-effect of printing "clap".</p>
<pre class="motoko"><code>import Debug &quot;mo:base/Debug&quot;
func clap() { Debug.print(&quot;clap&quot;) }</code></pre>
<p>Now, using futures, this code will clap once:</p>
<pre class="motoko"><code>let future = async { clap() };</code></pre>
<p>This remains the case, no matter how often you await
<code>future</code>. For example:</p>
<pre class="motoko"><code>let future = async { clap() };
await future;
await future;</code></pre>
<p>Using computations, on the other hand, the following definition has
no effect on its own:</p>
<pre class="motoko"><code>let computation = async* { clap() };</code></pre>
<p>But, the following example will clap twice:</p>
<pre class="motoko"><code>let computation = async* { clap() };
await* computation;
await* computation;</code></pre>
<p>:::danger</p>
<p>You should use <code>async*</code>/<code>await*</code> with care. An
ordinary <code>await</code> is a commit point in Motoko: all your state
changes will be committed at the <code>await</code> before suspension.
An <code>await*</code>, on the other hand, is not a commit point (since
its body may not await at all, or commit at some indefinite point). This
means that traps within the awaited computation may roll back the state
of the actor to the last commit point <em>before</em> the
<code>await*</code>, not to the state at the <code>await*</code>
itself.</p>
<p>:::</p>
<p>See the language manual for more details on the <a
href="../reference/language-manual#async-type-1"><code>async*</code>
type</a>, the <a
href="../reference/language-manual#async-1"><code>async*</code>
expression</a> and the <a
href="../reference/language-manual#await-1"><code>await*</code>
expression</a>.</p>
<h2 id="mops-packages-for-computations">Mops packages for
computations</h2>
<ul>
<li><a href="https://mops.one/star"><code>star</code></a>: Used for
handling asynchronous behavior and traps using <code>async*</code>
functions.</li>
</ul>
<img src="https://github.com/user-attachments/assets/844ca364-4d71-42b3-aaec-4a6c3509ee2e" alt="Logo" width="150" height="150" />
</body>
</html>
