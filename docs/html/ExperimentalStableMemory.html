<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>md/base/ExperimentalStableMemory.md</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">md/base/ExperimentalStableMemory.md</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#experimentalstablememory"
id="toc-experimentalstablememory">ExperimentalStableMemory</a>
<ul>
<li><a href="#value-size" id="toc-value-size">Value
<code>size</code></a></li>
<li><a href="#value-grow" id="toc-value-grow">Value
<code>grow</code></a></li>
<li><a href="#value-stablevarquery" id="toc-value-stablevarquery">Value
<code>stableVarQuery</code></a></li>
<li><a href="#value-loadnat32" id="toc-value-loadnat32">Value
<code>loadNat32</code></a></li>
<li><a href="#value-storenat32" id="toc-value-storenat32">Value
<code>storeNat32</code></a></li>
<li><a href="#value-loadnat8" id="toc-value-loadnat8">Value
<code>loadNat8</code></a></li>
<li><a href="#value-storenat8" id="toc-value-storenat8">Value
<code>storeNat8</code></a></li>
<li><a href="#value-loadnat16" id="toc-value-loadnat16">Value
<code>loadNat16</code></a></li>
<li><a href="#value-storenat16" id="toc-value-storenat16">Value
<code>storeNat16</code></a></li>
<li><a href="#value-loadnat64" id="toc-value-loadnat64">Value
<code>loadNat64</code></a></li>
<li><a href="#value-storenat64" id="toc-value-storenat64">Value
<code>storeNat64</code></a></li>
<li><a href="#value-loadint32" id="toc-value-loadint32">Value
<code>loadInt32</code></a></li>
<li><a href="#value-storeint32" id="toc-value-storeint32">Value
<code>storeInt32</code></a></li>
<li><a href="#value-loadint8" id="toc-value-loadint8">Value
<code>loadInt8</code></a></li>
<li><a href="#value-storeint8" id="toc-value-storeint8">Value
<code>storeInt8</code></a></li>
<li><a href="#value-loadint16" id="toc-value-loadint16">Value
<code>loadInt16</code></a></li>
<li><a href="#value-storeint16" id="toc-value-storeint16">Value
<code>storeInt16</code></a></li>
<li><a href="#value-loadint64" id="toc-value-loadint64">Value
<code>loadInt64</code></a></li>
<li><a href="#value-storeint64" id="toc-value-storeint64">Value
<code>storeInt64</code></a></li>
<li><a href="#value-loadfloat" id="toc-value-loadfloat">Value
<code>loadFloat</code></a></li>
<li><a href="#value-storefloat" id="toc-value-storefloat">Value
<code>storeFloat</code></a></li>
<li><a href="#value-loadblob" id="toc-value-loadblob">Value
<code>loadBlob</code></a></li>
<li><a href="#value-storeblob" id="toc-value-storeblob">Value
<code>storeBlob</code></a></li>
</ul></li>
</ul>
</nav>
<h1 id="experimentalstablememory">ExperimentalStableMemory</h1>
<p>Byte-level access to (virtual) <em>stable memory</em>.</p>
<p><strong>WARNING</strong>: As its name suggests, this library is
<strong>experimental</strong>, subject to change and may be replaced by
safer alternatives in later versions of Motoko. Use at your own risk and
discretion.</p>
<p><strong>DEPRECATION</strong>: Use of
<code>ExperimentalStableMemory</code> library may be deprecated in
future. Going forward, users should consider using library
<code>Region.mo</code> to allocate <em>isolated</em> regions of memory
instead. Using dedicated regions for different user applications ensures
that writing to one region will not affect the state of another,
unrelated region.</p>
<p>This is a lightweight abstraction over IC <em>stable memory</em> and
supports persisting raw binary data across Motoko upgrades. Use of this
module is fully compatible with Motoko's use of <em>stable
variables</em>, whose persistence mechanism also uses (real) IC stable
memory internally, but does not interfere with this API.</p>
<p>Memory is allocated, using <code>grow(pages)</code>, sequentially and
on demand, in units of 64KiB pages, starting with 0 allocated pages. New
pages are zero initialized. Growth is capped by a soft limit on page
count controlled by compile-time flag
<code>--max-stable-pages &lt;n&gt;</code> (the default is 65536, or
4GiB).</p>
<p>Each <code>load</code> operation loads from byte address
<code>offset</code> in little-endian format using the natural bit-width
of the type in question. The operation traps if attempting to read
beyond the current stable memory size.</p>
<p>Each <code>store</code> operation stores to byte address
<code>offset</code> in little-endian format using the natural bit-width
of the type in question. The operation traps if attempting to write
beyond the current stable memory size.</p>
<p>Text values can be handled by using <code>Text.decodeUtf8</code> and
<code>Text.encodeUtf8</code>, in conjunction with <code>loadBlob</code>
and <code>storeBlob</code>.</p>
<p>The current page allocation and page contents is preserved across
upgrades.</p>
<p>NB: The IC's actual stable memory size (<code>ic0.stable_size</code>)
may exceed the page size reported by Motoko function
<code>size()</code>. This (and the cap on growth) are to accommodate
Motoko's stable variables. Applications that plan to use Motoko stable
variables sparingly or not at all can increase
<code>--max-stable-pages</code> as desired, approaching the IC maximum
(initially 8GiB, then 32Gib, currently 64Gib). All applications should
reserve at least one page for stable variable data, even when no stable
variables are used.</p>
<p>Usage:</p>
<pre class="motoko"><code>import StableMemory &quot;mo:base/ExperimentalStableMemory&quot;;</code></pre>
<h2 id="value-size">Value <code>size</code></h2>
<pre class="motoko"><code>let size : () -&gt; (pages : Nat64)</code></pre>
<p>Current size of the stable memory, in pages. Each page is 64KiB
(65536 bytes). Initially <code>0</code>. Preserved across upgrades,
together with contents of allocated stable memory.</p>
<p>Example:</p>
<pre class="motoko"><code>let beforeSize = StableMemory.size();
ignore StableMemory.grow(10);
let afterSize = StableMemory.size();
afterSize - beforeSize // =&gt; 10</code></pre>
<h2 id="value-grow">Value <code>grow</code></h2>
<pre class="motoko"><code>let grow : (newPages : Nat64) -&gt; (oldPages : Nat64)</code></pre>
<p>Grow current <code>size</code> of stable memory by the given number
of pages. Each page is 64KiB (65536 bytes). Returns the previous
<code>size</code> when able to grow. Returns
<code>0xFFFF_FFFF_FFFF_FFFF</code> if remaining pages insufficient.
Every new page is zero-initialized, containing byte 0x00 at every
offset. Function <code>grow</code> is capped by a soft limit on
<code>size</code> controlled by compile-time flag
<code>--max-stable-pages &lt;n&gt;</code> (the default is 65536, or
4GiB).</p>
<p>Example:</p>
<pre class="motoko"><code>import Error &quot;mo:base/Error&quot;;

let beforeSize = StableMemory.grow(10);
if (beforeSize == 0xFFFF_FFFF_FFFF_FFFF) {
  throw Error.reject(&quot;Out of memory&quot;);
};
let afterSize = StableMemory.size();
afterSize - beforeSize // =&gt; 10</code></pre>
<h2 id="value-stablevarquery">Value <code>stableVarQuery</code></h2>
<pre class="motoko"><code>let stableVarQuery : () -&gt; (shared query () -&gt; async { size : Nat64 })</code></pre>
<p>Returns a query that, when called, returns the number of bytes of
(real) IC stable memory that would be occupied by persisting its current
stable variables before an upgrade. This function may be used to monitor
or limit real stable memory usage. The query computes the estimate by
running the first half of an upgrade, including any
<code>preupgrade</code> system method. Like any other query, its state
changes are discarded so no actual upgrade (or other state change) takes
place. The query can only be called by the enclosing actor and will trap
for other callers.</p>
<p>Example:</p>
<pre class="motoko"><code>actor {
  stable var state = &quot;&quot;;
  public func example() : async Text {
    let memoryUsage = StableMemory.stableVarQuery();
    let beforeSize = (await memoryUsage()).size;
    state #= &quot;abcdefghijklmnopqrstuvwxyz&quot;;
    let afterSize = (await memoryUsage()).size;
    debug_show (afterSize - beforeSize)
  };
};</code></pre>
<h2 id="value-loadnat32">Value <code>loadNat32</code></h2>
<pre class="motoko"><code>let loadNat32 : (offset : Nat64) -&gt; Nat32</code></pre>
<p>Loads a <code>Nat32</code> value from stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 123;
StableMemory.storeNat32(offset, value);
StableMemory.loadNat32(offset) // =&gt; 123</code></pre>
<h2 id="value-storenat32">Value <code>storeNat32</code></h2>
<pre class="motoko"><code>let storeNat32 : (offset : Nat64, value : Nat32) -&gt; ()</code></pre>
<p>Stores a <code>Nat32</code> value in stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 123;
StableMemory.storeNat32(offset, value);
StableMemory.loadNat32(offset) // =&gt; 123</code></pre>
<h2 id="value-loadnat8">Value <code>loadNat8</code></h2>
<pre class="motoko"><code>let loadNat8 : (offset : Nat64) -&gt; Nat8</code></pre>
<p>Loads a <code>Nat8</code> value from stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 123;
StableMemory.storeNat8(offset, value);
StableMemory.loadNat8(offset) // =&gt; 123</code></pre>
<h2 id="value-storenat8">Value <code>storeNat8</code></h2>
<pre class="motoko"><code>let storeNat8 : (offset : Nat64, value : Nat8) -&gt; ()</code></pre>
<p>Stores a <code>Nat8</code> value in stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 123;
StableMemory.storeNat8(offset, value);
StableMemory.loadNat8(offset) // =&gt; 123</code></pre>
<h2 id="value-loadnat16">Value <code>loadNat16</code></h2>
<pre class="motoko"><code>let loadNat16 : (offset : Nat64) -&gt; Nat16</code></pre>
<p>Loads a <code>Nat16</code> value from stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 123;
StableMemory.storeNat16(offset, value);
StableMemory.loadNat16(offset) // =&gt; 123</code></pre>
<h2 id="value-storenat16">Value <code>storeNat16</code></h2>
<pre class="motoko"><code>let storeNat16 : (offset : Nat64, value : Nat16) -&gt; ()</code></pre>
<p>Stores a <code>Nat16</code> value in stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 123;
StableMemory.storeNat16(offset, value);
StableMemory.loadNat16(offset) // =&gt; 123</code></pre>
<h2 id="value-loadnat64">Value <code>loadNat64</code></h2>
<pre class="motoko"><code>let loadNat64 : (offset : Nat64) -&gt; Nat64</code></pre>
<p>Loads a <code>Nat64</code> value from stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 123;
StableMemory.storeNat64(offset, value);
StableMemory.loadNat64(offset) // =&gt; 123</code></pre>
<h2 id="value-storenat64">Value <code>storeNat64</code></h2>
<pre class="motoko"><code>let storeNat64 : (offset : Nat64, value : Nat64) -&gt; ()</code></pre>
<p>Stores a <code>Nat64</code> value in stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 123;
StableMemory.storeNat64(offset, value);
StableMemory.loadNat64(offset) // =&gt; 123</code></pre>
<h2 id="value-loadint32">Value <code>loadInt32</code></h2>
<pre class="motoko"><code>let loadInt32 : (offset : Nat64) -&gt; Int32</code></pre>
<p>Loads an <code>Int32</code> value from stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 123;
StableMemory.storeInt32(offset, value);
StableMemory.loadInt32(offset) // =&gt; 123</code></pre>
<h2 id="value-storeint32">Value <code>storeInt32</code></h2>
<pre class="motoko"><code>let storeInt32 : (offset : Nat64, value : Int32) -&gt; ()</code></pre>
<p>Stores an <code>Int32</code> value in stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 123;
StableMemory.storeInt32(offset, value);
StableMemory.loadInt32(offset) // =&gt; 123</code></pre>
<h2 id="value-loadint8">Value <code>loadInt8</code></h2>
<pre class="motoko"><code>let loadInt8 : (offset : Nat64) -&gt; Int8</code></pre>
<p>Loads an <code>Int8</code> value from stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 123;
StableMemory.storeInt8(offset, value);
StableMemory.loadInt8(offset) // =&gt; 123</code></pre>
<h2 id="value-storeint8">Value <code>storeInt8</code></h2>
<pre class="motoko"><code>let storeInt8 : (offset : Nat64, value : Int8) -&gt; ()</code></pre>
<p>Stores an <code>Int8</code> value in stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 123;
StableMemory.storeInt8(offset, value);
StableMemory.loadInt8(offset) // =&gt; 123</code></pre>
<h2 id="value-loadint16">Value <code>loadInt16</code></h2>
<pre class="motoko"><code>let loadInt16 : (offset : Nat64) -&gt; Int16</code></pre>
<p>Loads an <code>Int16</code> value from stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 123;
StableMemory.storeInt16(offset, value);
StableMemory.loadInt16(offset) // =&gt; 123</code></pre>
<h2 id="value-storeint16">Value <code>storeInt16</code></h2>
<pre class="motoko"><code>let storeInt16 : (offset : Nat64, value : Int16) -&gt; ()</code></pre>
<p>Stores an <code>Int16</code> value in stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 123;
StableMemory.storeInt16(offset, value);
StableMemory.loadInt16(offset) // =&gt; 123</code></pre>
<h2 id="value-loadint64">Value <code>loadInt64</code></h2>
<pre class="motoko"><code>let loadInt64 : (offset : Nat64) -&gt; Int64</code></pre>
<p>Loads an <code>Int64</code> value from stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 123;
StableMemory.storeInt64(offset, value);
StableMemory.loadInt64(offset) // =&gt; 123</code></pre>
<h2 id="value-storeint64">Value <code>storeInt64</code></h2>
<pre class="motoko"><code>let storeInt64 : (offset : Nat64, value : Int64) -&gt; ()</code></pre>
<p>Stores an <code>Int64</code> value in stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 123;
StableMemory.storeInt64(offset, value);
StableMemory.loadInt64(offset) // =&gt; 123</code></pre>
<h2 id="value-loadfloat">Value <code>loadFloat</code></h2>
<pre class="motoko"><code>let loadFloat : (offset : Nat64) -&gt; Float</code></pre>
<p>Loads a <code>Float</code> value from stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 1.25;
StableMemory.storeFloat(offset, value);
StableMemory.loadFloat(offset) // =&gt; 1.25</code></pre>
<h2 id="value-storefloat">Value <code>storeFloat</code></h2>
<pre class="motoko"><code>let storeFloat : (offset : Nat64, value : Float) -&gt; ()</code></pre>
<p>Stores a <code>Float</code> value in stable memory at the given
<code>offset</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>let offset = 0;
let value = 1.25;
StableMemory.storeFloat(offset, value);
StableMemory.loadFloat(offset) // =&gt; 1.25</code></pre>
<h2 id="value-loadblob">Value <code>loadBlob</code></h2>
<pre class="motoko"><code>let loadBlob : (offset : Nat64, size : Nat) -&gt; Blob</code></pre>
<p>Load <code>size</code> bytes starting from <code>offset</code> as a
<code>Blob</code>. Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>import Blob &quot;mo:base/Blob&quot;;

let offset = 0;
let value = Blob.fromArray([1, 2, 3]);
let size = value.size();
StableMemory.storeBlob(offset, value);
Blob.toArray(StableMemory.loadBlob(offset, size)) // =&gt; [1, 2, 3]</code></pre>
<h2 id="value-storeblob">Value <code>storeBlob</code></h2>
<pre class="motoko"><code>let storeBlob : (offset : Nat64, value : Blob) -&gt; ()</code></pre>
<p>Write bytes of <code>blob</code> beginning at <code>offset</code>.
Traps on an out-of-bounds access.</p>
<p>Example:</p>
<pre class="motoko"><code>import Blob &quot;mo:base/Blob&quot;;

let offset = 0;
let value = Blob.fromArray([1, 2, 3]);
let size = value.size();
StableMemory.storeBlob(offset, value);
Blob.toArray(StableMemory.loadBlob(offset, size)) // =&gt; [1, 2, 3]</code></pre>
</body>
</html>
