<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>md/writing-motoko/writing-intro.md</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">md/writing-motoko/writing-intro.md</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#overview" id="toc-overview">Overview</a>
<ul>
<li><a href="#actors" id="toc-actors">Actors</a></li>
<li><a href="#async-messages" id="toc-async-messages">Async
messages</a></li>
<li><a href="#modern-type-system" id="toc-modern-type-system">Modern
type system</a></li>
<li><a href="#autogenerated-idl-files"
id="toc-autogenerated-idl-files">Autogenerated IDL files</a></li>
<li><a href="#orthogonal-persistence"
id="toc-orthogonal-persistence">Orthogonal persistence</a></li>
<li><a href="#upgrades" id="toc-upgrades">Upgrades</a></li>
<li><a href="#source-code-organization"
id="toc-source-code-organization">Source code organization</a></li>
<li><a href="#next-steps" id="toc-next-steps">Next steps</a></li>
</ul></li>
</ul>
</nav>
<h1 id="overview">Overview</h1>
<p>The Motoko programming language is a new, modern and type safe
language for developers who want to build the next generation of
distributed applications on ICP, as it is specifically designed to
support the unique features of ICP while providing a familiar, yet
robust, programming environment. As a new language, Motoko is constantly
evolving with support for new features and other improvements.</p>
<p>The Motoko compiler, documentation and other tooling is <a
href="https://github.com/dfinity/motoko">open source</a> and released
under the Apache 2.0 license. Contributions are welcome.</p>
<h2 id="actors">Actors</h2>
<p>A <a
href="https://internetcomputer.org/docs/current/developer-docs/getting-started/development-workflow">canister
smart contract</a> is expressed as a Motoko <a
href="actors-async.md">actor</a>. An actor is an autonomous object that
fully encapsulates its state and communicates with other actors only
through asynchronous messages.</p>
<p>For example, this code defines a stateful <code>Counter</code>
actor.</p>
<pre class="motoko"><code></code></pre>
<p>Its single public function, <code>inc()</code>, can be invoked by
this and other actors, to both update and read the current state of its
private field <code>value</code>.</p>
<h2 id="async-messages">Async messages</h2>
<p>On ICP, <a
href="https://internetcomputer.org/docs/current/developer-docs/smart-contracts/call/overview">canisters
can communicate</a> with other canisters by sending <a
href="async-data.md">asynchronous messages</a>. Asynchronous messages
are function calls that return a <strong>future</strong>, and use an
<code>await</code> construct that allows you to suspend execution until
a future has completed. This simple feature avoids creating a loop of
explicit asynchronous callbacks in other languages.</p>
<pre class="motoko"><code></code></pre>
<h2 id="modern-type-system">Modern type system</h2>
<p>Motoko has been designed to be intuitive to those familiar with
JavaScript and other popular languages, but offers modern features such
as sound structural types, generics, variant types, and statically
checked pattern matching.</p>
<pre class="motoko"><code></code></pre>
<h2 id="autogenerated-idl-files">Autogenerated IDL files</h2>
<p>A Motoko actor always presents a typed interface to its clients as a
suite of named functions with argument and result types.</p>
<p>The Motoko compiler and the IC SDK can emit this interface in a
language neutral format called <a href="candid-ui.md">Candid</a>. Other
canisters, browser resident code, and mobile apps that support Candid
can use the actor’s services. The Motoko compiler can consume and
produce Candid files, allowing Motoko to seamlessly interact with
canisters implemented in other programming languages (provided they
support Candid).</p>
<p>For example, the previous Motoko <code>Counter</code> actor has the
following Candid interface:</p>
<pre class="candid"><code>service Counter : {
  inc : () -&gt; (nat);
}</code></pre>
<h2 id="orthogonal-persistence">Orthogonal persistence</h2>
<p>ICP persists the memory and other state of your canister as it
executes. The state of a Motoko actor, including its in-memory data
structures, survive indefinitely. Actor state does not need to be
explicitly restored and saved to external storage.</p>
<p>For example, in the following <code>Registry</code> actor that
assigns sequential IDs to textual names, the state of the hash table is
preserved across calls, even though the state of the actor is replicated
across many ICP node machines and typically not resident in memory:</p>
<pre class="motoko"><code></code></pre>
<h2 id="upgrades">Upgrades</h2>
<p>Motoko provides numerous features to help you leverage orthogonal
persistence, including the ability to retain a canister’s data as you <a
href="../canister-maintenance/upgrades.md">upgrade</a> the code of the
canister.</p>
<p>For example, Motoko lets you declare certain variables as
<code>stable</code>. These variables are automatically preserved across
canister upgrades.</p>
<p>Consider a stable counter:</p>
<pre class="motoko"><code></code></pre>
<p>It can be installed, incremented <em>n</em> times, and then upgraded
without interruption:</p>
<pre class="motoko"><code></code></pre>
<p>The <code>value</code> was declared <code>stable</code>, meaning the
current state, <em>n</em>, of the service is retained after the upgrade.
Counting will continue from <em>n</em>, not restart from
<code>0</code>.</p>
<p>The new interface is compatible with the previous one, allowing
existing clients referencing the canister to continue to work. New
clients will be able to exploit its upgraded functionality, in this
example the additional <code>reset</code> function.</p>
<p>For scenarios that can’t be solved using stable variables alone,
Motoko provides user-definable upgrade hooks that run immediately before
and after an upgrade, allowing you to migrate arbitrary state to stable
variables.</p>
<h2 id="source-code-organization">Source code organization</h2>
<p>Motoko allows for separating different portions of code out of the
<code>main.mo</code> file into separate modules. This can be useful for
breaking up large pieces of source code into smaller, more manageable
pieces.</p>
<p>One common approach is to exclude type definitions from the
<code>main.mo</code> file and instead include them in a
<code>Types.mo</code> file.</p>
<p>Another approach is to declare stable variables and public methods in
the <code>main.mo</code> file, and then break out all the logic and
types into other files. This workflow can be beneficial for efficient
unit testing.</p>
<h2 id="next-steps">Next steps</h2>
<p>To start writing Motoko code, start by reading the in-depth
documentation for some of the concepts described above:</p>
<ul>
<li><p><a href="actors-async.md">Actors</a></p></li>
<li><p><a href="actor-classes.md">Actor classes</a></p></li>
<li><p><a href="async-data.md">Async data</a></p></li>
<li><p><a href="caller-id.md">Caller identification</a></p></li>
</ul>
<p>The Motoko programming language continues to evolve with each release
of the <a
href="https://internetcomputer.org/docs/current/developer-docs/setup/install">IC
SDK</a> and with ongoing updates to the Motoko compiler. Check back
regularly to try new features and see what’s changed.</p>
<img src="https://github.com/user-attachments/assets/844ca364-4d71-42b3-aaec-4a6c3509ee2e" alt="Logo" width="150" height="150" />
</body>
</html>
