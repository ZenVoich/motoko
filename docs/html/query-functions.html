<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>md/writing-motoko/query-functions.md</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">md/writing-motoko/query-functions.md</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#query-functions" id="toc-query-functions">Query
functions</a>
<ul>
<li><a href="#overview" id="toc-overview">Overview</a></li>
<li><a href="#query-functions-1" id="toc-query-functions-1">Query
functions</a></li>
<li><a href="#composite-query-functions"
id="toc-composite-query-functions">Composite query functions</a></li>
</ul></li>
</ul>
</nav>
<h1 id="query-functions">Query functions</h1>
<h2 id="overview">Overview</h2>
<p>In ICP terminology, <strong>update</strong> messages, also referred
to as calls, can alter the state of the canister when called. Effecting
a state change requires agreement amongst the distributed replicas
before the network can commit the change and return a result. Reaching
consensus is an expensive process with relatively high latency.</p>
<p>For the parts of applications that donâ€™t require the guarantees of
consensus, the ICP supports more efficient query operations. These are
able to read the state of a canister from a single replica, modify a
snapshot during their execution and return a result, but cannot
permanently alter the state or send further messages.</p>
<h2 id="query-functions-1">Query functions</h2>
<p>Motoko supports the implementation of queries using
<code>query</code> functions. The <code>query</code> keyword modifies
the declaration of a shared actor function so that it executes with
non-committing and faster query semantics.</p>
<p>For example, consider the following <code>Counter</code> actor with a
<code>read</code> function called <code>peek</code>:</p>
<pre class="motoko"><code></code></pre>
<p>The <code>peek()</code> function might be used by a
<code>Counter</code> frontend offering a quick, but less trustworthy,
display of the current counter value.</p>
<p>Query functions can be called from non-query functions. Because those
nested calls require consensus, the efficiency gains of nested query
calls will be modest at best.</p>
<p>The <code>query</code> modifier is reflected in the type of a query
function:</p>
<pre class="motoko"><code>  peek : shared query () -&gt; async Nat</code></pre>
<p>As before, in <code>query</code> declarations and actor types the
<code>shared</code> keyword can be omitted.</p>
<p>:::info</p>
<p>A query method cannot call an actor function and will result in an
error when the code is compiled. Calls to ordinary functions are
permitted.</p>
<p>:::</p>
<h2 id="composite-query-functions">Composite query functions</h2>
<p>Queries are limited in what they can do. In particular, they cannot
themselves issue further messages, including queries.</p>
<p>To address this limitation, the ICP supports another type of query
function called a composite query.</p>
<p>Like plain queries, the state changes made by a composite query are
transient, isolated and never committed. Moreover, composite queries
cannot call update functions, including those implicit in
<code>async</code> expressions, which require update calls under the
hood.</p>
<p>Unlike plain queries, composite queries can call query functions and
composite query functions on the same and other actors, but only
provided those actors reside on the same subnet.</p>
<p>As a contrived example, consider generalizing the previous
<code>Counter</code> actor to a class of counters. Each instance of the
class provides an additional <code>composite query</code> to sum the
values of a given array of counters:</p>
<pre class="motoko"><code></code></pre>
<p>Declaring <code>sum</code> as a <code>composite query</code> enables
it call the <code>peek</code> queries of its argument counters.</p>
<p>While update messages can call plain query functions, they cannot
call composite query functions. This distinction, which is dictated by
the current capabilities of ICP, explains why query functions and
composite query functions are regarded as distinct types of shared
functions.</p>
<p>Note that the <code>composite query</code> modifier is reflected in
the type of a composite query function:</p>
<pre class="motoko"><code>  sum : shared composite query ([Counter]) -&gt; async Nat</code></pre>
<p>Since only a composite query can call another composite query, you
may be wondering how any composite query gets called at all?</p>
<p>Composite queries are initiated outside ICP, typically by an
application (such as a browser frontend) sending an ingress message
invoking a composite query on a backend actor.</p>
<p>:::danger</p>
<p>The Internet Computer's semantics of composite queries ensures that
state changes made by a composite query are isolated from other
inter-canister calls, including recursive queries, to the same
actor.</p>
<p>In particular, a composite query call rolls back its state on
function exit, but is also does not pass state changes to sub-query or
sub-composite-query calls. Repeated calls, which include recursive
calls, have different semantics from calls that accumulate state
changes.</p>
<p>In sequential calls, the internal state changes of preceding queries
will have no effect on subsequent queries, nor will the queries observe
any local state changes made by the enclosing composite query. Local
states changes made by the composite query are preserved across the
calls until finally being rolled-back on exit from the composite
query.</p>
<p>This semantics can lead to surprising behavior for users accustomed
to ordinary imperative programming.</p>
<p>Consider this example containing the composite query
<code>test</code> that calls query <code>q</code> and composite query
<code>cq</code>.</p>
<pre class="motoko"><code></code></pre>
<p>When <code>state</code> is <code>0</code>, a call to
<code>test</code> returns</p>
<pre><code>{s0 = 0; s1 = 0; s2 = 0; s3 = 3_000}</code></pre>
<p>This is because none of the local updates to <code>state</code> are
visible to any of the callers or callees.</p>
<p>:::</p>
<img src="https://github.com/user-attachments/assets/844ca364-4d71-42b3-aaec-4a6c3509ee2e" alt="Logo" width="150" height="150" />
</body>
</html>
