<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>md/base/Text.md</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">md/base/Text.md</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#text" id="toc-text">Text</a>
<ul>
<li><a href="#type-text" id="toc-type-text">Type
<code>Text</code></a></li>
<li><a href="#value-fromchar" id="toc-value-fromchar">Value
<code>fromChar</code></a></li>
<li><a href="#function-toiter" id="toc-function-toiter">Function
<code>toIter</code></a></li>
<li><a href="#function-toarray" id="toc-function-toarray">Function
<code>toArray</code></a></li>
<li><a href="#function-tovararray" id="toc-function-tovararray">Function
<code>toVarArray</code></a></li>
<li><a href="#function-fromiter" id="toc-function-fromiter">Function
<code>fromIter</code></a></li>
<li><a href="#function-size" id="toc-function-size">Function
<code>size</code></a></li>
<li><a href="#function-hash" id="toc-function-hash">Function
<code>hash</code></a></li>
<li><a href="#function-concat" id="toc-function-concat">Function
<code>concat</code></a></li>
<li><a href="#function-equal" id="toc-function-equal">Function
<code>equal</code></a></li>
<li><a href="#function-notequal" id="toc-function-notequal">Function
<code>notEqual</code></a></li>
<li><a href="#function-less" id="toc-function-less">Function
<code>less</code></a></li>
<li><a href="#function-lessorequal"
id="toc-function-lessorequal">Function <code>lessOrEqual</code></a></li>
<li><a href="#function-greater" id="toc-function-greater">Function
<code>greater</code></a></li>
<li><a href="#function-greaterorequal"
id="toc-function-greaterorequal">Function
<code>greaterOrEqual</code></a></li>
<li><a href="#function-compare" id="toc-function-compare">Function
<code>compare</code></a></li>
<li><a href="#function-join" id="toc-function-join">Function
<code>join</code></a></li>
<li><a href="#function-map" id="toc-function-map">Function
<code>map</code></a></li>
<li><a href="#function-translate" id="toc-function-translate">Function
<code>translate</code></a></li>
<li><a href="#type-pattern" id="toc-type-pattern">Type
<code>Pattern</code></a></li>
<li><a href="#function-split" id="toc-function-split">Function
<code>split</code></a></li>
<li><a href="#function-tokens" id="toc-function-tokens">Function
<code>tokens</code></a></li>
<li><a href="#function-contains" id="toc-function-contains">Function
<code>contains</code></a></li>
<li><a href="#function-startswith" id="toc-function-startswith">Function
<code>startsWith</code></a></li>
<li><a href="#function-endswith" id="toc-function-endswith">Function
<code>endsWith</code></a></li>
<li><a href="#function-replace" id="toc-function-replace">Function
<code>replace</code></a></li>
<li><a href="#function-stripstart" id="toc-function-stripstart">Function
<code>stripStart</code></a></li>
<li><a href="#function-stripend" id="toc-function-stripend">Function
<code>stripEnd</code></a></li>
<li><a href="#function-trimstart" id="toc-function-trimstart">Function
<code>trimStart</code></a></li>
<li><a href="#function-trimend" id="toc-function-trimend">Function
<code>trimEnd</code></a></li>
<li><a href="#function-trim" id="toc-function-trim">Function
<code>trim</code></a></li>
<li><a href="#function-comparewith"
id="toc-function-comparewith">Function <code>compareWith</code></a></li>
<li><a href="#value-encodeutf8" id="toc-value-encodeutf8">Value
<code>encodeUtf8</code></a></li>
<li><a href="#value-decodeutf8" id="toc-value-decodeutf8">Value
<code>decodeUtf8</code></a></li>
<li><a href="#value-tolowercase" id="toc-value-tolowercase">Value
<code>toLowercase</code></a></li>
<li><a href="#value-touppercase" id="toc-value-touppercase">Value
<code>toUppercase</code></a></li>
</ul></li>
</ul>
</nav>
<h1 id="text">Text</h1>
<p>Utility functions for <code>Text</code> values.</p>
<p>A <code>Text</code> value represents human-readable text as a
sequence of characters of type <code>Char</code>.</p>
<pre class="motoko"><code>let text = &quot;Hello!&quot;;
let size = text.size(); // 6
let iter = text.chars(); // iterator (&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;!&#39;)
let concat = text # &quot; ðŸ‘‹&quot;; // &quot;Hello! ðŸ‘‹&quot;</code></pre>
<p>The <code>"mo:base/Text"</code> module defines additional operations
on <code>Text</code> values.</p>
<p>Import the module from the base library:</p>
<pre class="motoko"><code>import Text &quot;mo:base/Text&quot;;</code></pre>
<p>Note: <code>Text</code> values are represented as ropes of UTF-8
character sequences with O(1) concatenation.</p>
<h2 id="type-text">Type <code>Text</code></h2>
<pre class="motoko"><code>type Text = Prim.Types.Text</code></pre>
<p>The type corresponding to primitive <code>Text</code> values.</p>
<pre class="motoko"><code>let hello = &quot;Hello!&quot;;
let emoji = &quot;ðŸ‘‹&quot;;
let concat = hello # &quot; &quot; # emoji; // &quot;Hello! ðŸ‘‹&quot;</code></pre>
<h2 id="value-fromchar">Value <code>fromChar</code></h2>
<pre class="motoko"><code>let fromChar : (c : Char) -&gt; Text</code></pre>
<p>Converts the given <code>Char</code> to a <code>Text</code>
value.</p>
<pre class="motoko"><code>let text = Text.fromChar(&#39;A&#39;); // &quot;A&quot;</code></pre>
<h2 id="function-toiter">Function <code>toIter</code></h2>
<pre class="motoko"><code>func toIter(t : Text) : Iter.Iter&lt;Char&gt;</code></pre>
<p>Iterates over each <code>Char</code> value in the given
<code>Text</code>.</p>
<p>Equivalent to calling the <code>t.chars()</code> method where
<code>t</code> is a <code>Text</code> value.</p>
<pre class="motoko"><code>import { print } &quot;mo:base/Debug&quot;;

for (c in Text.toIter(&quot;abc&quot;)) {
  print(debug_show c);
}</code></pre>
<h2 id="function-toarray">Function <code>toArray</code></h2>
<pre class="motoko"><code>func toArray(t : Text) : [Char]</code></pre>
<p>Creates a new <code>Array</code> containing characters of the given
<code>Text</code>.</p>
<p>Equivalent to <code>Iter.toArray(t.chars())</code>.</p>
<pre class="motoko"><code>assert Text.toArray(&quot;CafÃ©&quot;) == [&#39;C&#39;, &#39;a&#39;, &#39;f&#39;, &#39;Ã©&#39;];</code></pre>
<p>Runtime: O(t.size()) Space: O(t.size())</p>
<h2 id="function-tovararray">Function <code>toVarArray</code></h2>
<pre class="motoko"><code>func toVarArray(t : Text) : [var Char]</code></pre>
<p>Creates a new mutable <code>Array</code> containing characters of the
given <code>Text</code>.</p>
<p>Equivalent to <code>Iter.toArrayMut(t.chars())</code>.</p>
<pre class="motoko"><code>assert Text.toVarArray(&quot;CafÃ©&quot;) == [var &#39;C&#39;, &#39;a&#39;, &#39;f&#39;, &#39;Ã©&#39;];</code></pre>
<p>Runtime: O(t.size()) Space: O(t.size())</p>
<h2 id="function-fromiter">Function <code>fromIter</code></h2>
<pre class="motoko"><code>func fromIter(cs : Iter.Iter&lt;Char&gt;) : Text</code></pre>
<p>Creates a <code>Text</code> value from a <code>Char</code>
iterator.</p>
<pre class="motoko"><code>let text = Text.fromIter([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].vals()); // &quot;abc&quot;</code></pre>
<h2 id="function-size">Function <code>size</code></h2>
<pre class="motoko"><code>func size(t : Text) : Nat</code></pre>
<p>Returns the number of characters in the given <code>Text</code>.</p>
<p>Equivalent to calling <code>t.size()</code> where <code>t</code> is a
<code>Text</code> value.</p>
<pre class="motoko"><code>let size = Text.size(&quot;abc&quot;); // 3</code></pre>
<h2 id="function-hash">Function <code>hash</code></h2>
<pre class="motoko"><code>func hash(t : Text) : Hash.Hash</code></pre>
<p>Returns a hash obtained by using the <code>djb2</code> algorithm (<a
href="http://www.cse.yorku.ca/~oz/hash.html">more details</a>).</p>
<pre class="motoko"><code>let hash = Text.hash(&quot;abc&quot;);</code></pre>
<p>Note: this algorithm is intended for use in data structures rather
than as a cryptographic hash function.</p>
<h2 id="function-concat">Function <code>concat</code></h2>
<pre class="motoko"><code>func concat(t1 : Text, t2 : Text) : Text</code></pre>
<p>Returns <code>t1 # t2</code>, where <code>#</code> is the
<code>Text</code> concatenation operator.</p>
<pre class="motoko"><code>let a = &quot;Hello&quot;;
let b = &quot;There&quot;;
let together = a # b; // &quot;HelloThere&quot;
let withSpace = a # &quot; &quot; # b; // &quot;Hello There&quot;
let togetherAgain = Text.concat(a, b); // &quot;HelloThere&quot;</code></pre>
<h2 id="function-equal">Function <code>equal</code></h2>
<pre class="motoko"><code>func equal(t1 : Text, t2 : Text) : Bool</code></pre>
<p>Returns <code>t1 == t2</code>.</p>
<h2 id="function-notequal">Function <code>notEqual</code></h2>
<pre class="motoko"><code>func notEqual(t1 : Text, t2 : Text) : Bool</code></pre>
<p>Returns <code>t1 != t2</code>.</p>
<h2 id="function-less">Function <code>less</code></h2>
<pre class="motoko"><code>func less(t1 : Text, t2 : Text) : Bool</code></pre>
<p>Returns <code>t1 &lt; t2</code>.</p>
<h2 id="function-lessorequal">Function <code>lessOrEqual</code></h2>
<pre class="motoko"><code>func lessOrEqual(t1 : Text, t2 : Text) : Bool</code></pre>
<p>Returns <code>t1 &lt;= t2</code>.</p>
<h2 id="function-greater">Function <code>greater</code></h2>
<pre class="motoko"><code>func greater(t1 : Text, t2 : Text) : Bool</code></pre>
<p>Returns <code>t1 &gt; t2</code>.</p>
<h2 id="function-greaterorequal">Function
<code>greaterOrEqual</code></h2>
<pre class="motoko"><code>func greaterOrEqual(t1 : Text, t2 : Text) : Bool</code></pre>
<p>Returns <code>t1 &gt;= t2</code>.</p>
<h2 id="function-compare">Function <code>compare</code></h2>
<pre class="motoko"><code>func compare(t1 : Text, t2 : Text) : {#less; #equal; #greater}</code></pre>
<p>Compares <code>t1</code> and <code>t2</code> lexicographically.</p>
<pre class="motoko"><code>import { print } &quot;mo:base/Debug&quot;;

print(debug_show Text.compare(&quot;abc&quot;, &quot;abc&quot;)); // #equal
print(debug_show Text.compare(&quot;abc&quot;, &quot;def&quot;)); // #less
print(debug_show Text.compare(&quot;abc&quot;, &quot;ABC&quot;)); // #greater</code></pre>
<h2 id="function-join">Function <code>join</code></h2>
<pre class="motoko"><code>func join(sep : Text, ts : Iter.Iter&lt;Text&gt;) : Text</code></pre>
<p>Join an iterator of <code>Text</code> values with a given
delimiter.</p>
<pre class="motoko"><code>let joined = Text.join(&quot;, &quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].vals()); // &quot;a, b, c&quot;</code></pre>
<h2 id="function-map">Function <code>map</code></h2>
<pre class="motoko"><code>func map(t : Text, f : Char -&gt; Char) : Text</code></pre>
<p>Applies a function to each character in a <code>Text</code> value,
returning the concatenated <code>Char</code> results.</p>
<pre class="motoko"><code>// Replace all occurrences of &#39;?&#39; with &#39;!&#39;
let result = Text.map(&quot;Motoko?&quot;, func(c) {
  if (c == &#39;?&#39;) &#39;!&#39;
  else c
});</code></pre>
<h2 id="function-translate">Function <code>translate</code></h2>
<pre class="motoko"><code>func translate(t : Text, f : Char -&gt; Text) : Text</code></pre>
<p>Returns the result of applying <code>f</code> to each character in
<code>ts</code>, concatenating the intermediate text values.</p>
<pre class="motoko"><code>// Replace all occurrences of &#39;?&#39; with &quot;!!&quot;
let result = Text.translate(&quot;Motoko?&quot;, func(c) {
  if (c == &#39;?&#39;) &quot;!!&quot;
  else Text.fromChar(c)
}); // &quot;Motoko!!&quot;</code></pre>
<h2 id="type-pattern">Type <code>Pattern</code></h2>
<pre class="motoko"><code>type Pattern = {#char : Char; #text : Text; #predicate : (Char -&gt; Bool)}</code></pre>
<p>A pattern <code>p</code> describes a sequence of characters. A
pattern has one of the following forms:</p>
<ul>
<li><code>#char c</code> matches the single character sequence,
<code>c</code>.</li>
<li><code>#text t</code> matches multi-character text sequence
<code>t</code>.</li>
<li><code>#predicate p</code> matches any single character sequence
<code>c</code> satisfying predicate <code>p(c)</code>.</li>
</ul>
<p>A <em>match</em> for <code>p</code> is any sequence of characters
matching the pattern <code>p</code>.</p>
<pre class="motoko"><code>let charPattern = #char &#39;A&#39;;
let textPattern = #text &quot;phrase&quot;;
let predicatePattern : Text.Pattern = #predicate (func(c) { c == &#39;A&#39; or c == &#39;B&#39; }); // matches &quot;A&quot; or &quot;B&quot;</code></pre>
<h2 id="function-split">Function <code>split</code></h2>
<pre class="motoko"><code>func split(t : Text, p : Pattern) : Iter.Iter&lt;Text&gt;</code></pre>
<p>Splits the input <code>Text</code> with the specified
<code>Pattern</code>.</p>
<p>Two fields are separated by exactly one match.</p>
<pre class="motoko"><code>let words = Text.split(&quot;This is a sentence.&quot;, #char &#39; &#39;);
Text.join(&quot;|&quot;, words) // &quot;This|is|a|sentence.&quot;</code></pre>
<h2 id="function-tokens">Function <code>tokens</code></h2>
<pre class="motoko"><code>func tokens(t : Text, p : Pattern) : Iter.Iter&lt;Text&gt;</code></pre>
<p>Returns a sequence of tokens from the input <code>Text</code>
delimited by the specified <code>Pattern</code>, derived from start to
end. A "token" is a non-empty maximal subsequence of <code>t</code> not
containing a match for pattern <code>p</code>. Two tokens may be
separated by one or more matches of <code>p</code>.</p>
<pre class="motoko"><code>let tokens = Text.tokens(&quot;this needs\n an   example&quot;, #predicate (func(c) { c == &#39; &#39; or c == &#39;\n&#39; }));
Text.join(&quot;|&quot;, tokens) // &quot;this|needs|an|example&quot;</code></pre>
<h2 id="function-contains">Function <code>contains</code></h2>
<pre class="motoko"><code>func contains(t : Text, p : Pattern) : Bool</code></pre>
<p>Returns <code>true</code> if the input <code>Text</code> contains a
match for the specified <code>Pattern</code>.</p>
<pre class="motoko"><code>Text.contains(&quot;Motoko&quot;, #text &quot;oto&quot;) // true</code></pre>
<h2 id="function-startswith">Function <code>startsWith</code></h2>
<pre class="motoko"><code>func startsWith(t : Text, p : Pattern) : Bool</code></pre>
<p>Returns <code>true</code> if the input <code>Text</code> starts with
a prefix matching the specified <code>Pattern</code>.</p>
<pre class="motoko"><code>Text.startsWith(&quot;Motoko&quot;, #text &quot;Mo&quot;) // true</code></pre>
<h2 id="function-endswith">Function <code>endsWith</code></h2>
<pre class="motoko"><code>func endsWith(t : Text, p : Pattern) : Bool</code></pre>
<p>Returns <code>true</code> if the input <code>Text</code> ends with a
suffix matching the specified <code>Pattern</code>.</p>
<pre class="motoko"><code>Text.endsWith(&quot;Motoko&quot;, #char &#39;o&#39;) // true</code></pre>
<h2 id="function-replace">Function <code>replace</code></h2>
<pre class="motoko"><code>func replace(t : Text, p : Pattern, r : Text) : Text</code></pre>
<p>Returns the input text <code>t</code> with all matches of pattern
<code>p</code> replaced by text <code>r</code>.</p>
<pre class="motoko"><code>let result = Text.replace(&quot;abcabc&quot;, #char &#39;a&#39;, &quot;A&quot;); // &quot;AbcAbc&quot;</code></pre>
<h2 id="function-stripstart">Function <code>stripStart</code></h2>
<pre class="motoko"><code>func stripStart(t : Text, p : Pattern) : ?Text</code></pre>
<p>Strips one occurrence of the given <code>Pattern</code> from the
beginning of the input <code>Text</code>. If you want to remove multiple
instances of the pattern, use <code>Text.trimStart()</code> instead.</p>
<pre class="motoko"><code>// Try to strip a nonexistent character
let none = Text.stripStart(&quot;abc&quot;, #char &#39;-&#39;); // null
// Strip just one &#39;-&#39;
let one = Text.stripStart(&quot;--abc&quot;, #char &#39;-&#39;); // ?&quot;-abc&quot;</code></pre>
<h2 id="function-stripend">Function <code>stripEnd</code></h2>
<pre class="motoko"><code>func stripEnd(t : Text, p : Pattern) : ?Text</code></pre>
<p>Strips one occurrence of the given <code>Pattern</code> from the end
of the input <code>Text</code>. If you want to remove multiple instances
of the pattern, use <code>Text.trimEnd()</code> instead.</p>
<pre class="motoko"><code>// Try to strip a nonexistent character
let none = Text.stripEnd(&quot;xyz&quot;, #char &#39;-&#39;); // null
// Strip just one &#39;-&#39;
let one = Text.stripEnd(&quot;xyz--&quot;, #char &#39;-&#39;); // ?&quot;xyz-&quot;</code></pre>
<h2 id="function-trimstart">Function <code>trimStart</code></h2>
<pre class="motoko"><code>func trimStart(t : Text, p : Pattern) : Text</code></pre>
<p>Trims the given <code>Pattern</code> from the start of the input
<code>Text</code>. If you only want to remove a single instance of the
pattern, use <code>Text.stripStart()</code> instead.</p>
<pre class="motoko"><code>let trimmed = Text.trimStart(&quot;---abc&quot;, #char &#39;-&#39;); // &quot;abc&quot;</code></pre>
<h2 id="function-trimend">Function <code>trimEnd</code></h2>
<pre class="motoko"><code>func trimEnd(t : Text, p : Pattern) : Text</code></pre>
<p>Trims the given <code>Pattern</code> from the end of the input
<code>Text</code>. If you only want to remove a single instance of the
pattern, use <code>Text.stripEnd()</code> instead.</p>
<pre class="motoko"><code>let trimmed = Text.trimEnd(&quot;xyz---&quot;, #char &#39;-&#39;); // &quot;xyz&quot;</code></pre>
<h2 id="function-trim">Function <code>trim</code></h2>
<pre class="motoko"><code>func trim(t : Text, p : Pattern) : Text</code></pre>
<p>Trims the given <code>Pattern</code> from both the start and end of
the input <code>Text</code>.</p>
<pre class="motoko"><code>let trimmed = Text.trim(&quot;---abcxyz---&quot;, #char &#39;-&#39;); // &quot;abcxyz&quot;</code></pre>
<h2 id="function-comparewith">Function <code>compareWith</code></h2>
<pre class="motoko"><code>func compareWith(t1 : Text, t2 : Text, cmp : (Char, Char) -&gt; {#less; #equal; #greater}) : {#less; #equal; #greater}</code></pre>
<p>Compares <code>t1</code> and <code>t2</code> using the provided
character-wise comparison function.</p>
<pre class="motoko"><code>import Char &quot;mo:base/Char&quot;;

Text.compareWith(&quot;abc&quot;, &quot;ABC&quot;, func(c1, c2) { Char.compare(c1, c2) }) // #greater</code></pre>
<h2 id="value-encodeutf8">Value <code>encodeUtf8</code></h2>
<pre class="motoko"><code>let encodeUtf8 : Text -&gt; Blob</code></pre>
<p>Returns a UTF-8 encoded <code>Blob</code> from the given
<code>Text</code>.</p>
<pre class="motoko"><code>let blob = Text.encodeUtf8(&quot;Hello&quot;);</code></pre>
<h2 id="value-decodeutf8">Value <code>decodeUtf8</code></h2>
<pre class="motoko"><code>let decodeUtf8 : Blob -&gt; ?Text</code></pre>
<p>Tries to decode the given <code>Blob</code> as UTF-8. Returns
<code>null</code> if the blob is not valid UTF-8.</p>
<pre class="motoko"><code>let text = Text.decodeUtf8(&quot;\48\65\6C\6C\6F&quot;); // ?&quot;Hello&quot;</code></pre>
<h2 id="value-tolowercase">Value <code>toLowercase</code></h2>
<pre class="motoko"><code>let toLowercase : Text -&gt; Text</code></pre>
<p>Returns the text argument in lowercase. WARNING: Unicode compliant
only when compiled, not interpreted.</p>
<pre class="motoko"><code>let text = Text.toLowercase(&quot;Good Day&quot;); // ?&quot;good day&quot;</code></pre>
<h2 id="value-touppercase">Value <code>toUppercase</code></h2>
<pre class="motoko"><code>let toUppercase : Text -&gt; Text</code></pre>
<p>Returns the text argument in uppercase. Unicode compliant. WARNING:
Unicode compliant only when compiled, not interpreted.</p>
<pre class="motoko"><code>let text = Text.toUppercase(&quot;Good Day&quot;); // ?&quot;GOOD DAY&quot;</code></pre>
</body>
</html>
