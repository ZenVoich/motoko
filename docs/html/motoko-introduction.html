<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>md/getting-started/motoko-introduction.md</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">md/getting-started/motoko-introduction.md</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a>
<ul>
<li><a href="#overview" id="toc-overview">Overview</a></li>
</ul></li>
<li><a href="#why-motoko" id="toc-why-motoko">Why Motoko?</a>
<ul>
<li><a href="#motivation-and-goals"
id="toc-motivation-and-goals">Motivation and goals</a></li>
<li><a href="#key-design-points" id="toc-key-design-points">Key design
points</a>
<ul>
<li><a href="#native-canister-smart-contract-support"
id="toc-native-canister-smart-contract-support">Native canister smart
contract support</a></li>
<li><a href="#code-sequentially-in-direct-style"
id="toc-code-sequentially-in-direct-style">Code sequentially in direct
style</a></li>
<li><a href="#modern-type-system" id="toc-modern-type-system">Modern
type system</a></li>
<li><a href="#autogenerated-idl-files"
id="toc-autogenerated-idl-files">Autogenerated IDL files</a></li>
<li><a href="#orthogonal-persistence"
id="toc-orthogonal-persistence">Orthogonal persistence</a></li>
<li><a href="#upgrades" id="toc-upgrades">Upgrades</a></li>
</ul></li>
<li><a href="#getting-started" id="toc-getting-started">Getting
started</a></li>
</ul></li>
</ul>
</nav>
<h1 id="introduction">Introduction</h1>
<h2 id="overview">Overview</h2>
<p>Motoko is a modern, general-purpose programming language you can use
specifically to author ICP canister smart contracts. Although aimed
primarily at ICP canister development, its design is general enough to
support future compilation to other targets.</p>
<p>Motoko is designed to be approachable for programmers who have some
basic familiarity with object-oriented and/or functional programming
idioms in either JavaScript, or another modern programming language,
such as Rust, Swift, TypeScript, C#, or Java.</p>
<p>Motoko provides:</p>
<ul>
<li><p>A high-level language for programming applications to run on
ICP.</p></li>
<li><p>A simple design that uses familiar syntax that is easy for
programmers to learn.</p></li>
<li><p>An <strong>actor-based</strong> programming model optimized for
efficient message handling.</p></li>
<li><p><strong>Orthogonal persistence</strong> for simple, safe, and
efficient data storage without a database or secondary memory.</p></li>
<li><p>An interpreter and compiler that you can use to test and compile
the WebAssembly code for autonomous applications.</p></li>
</ul>
<h1 id="why-motoko">Why Motoko?</h1>
<p>ICP supports programs written in different languages. The only
requirement is that the program must support compilation to WebAssembly
code. WebAssembly is a low-level computer instruction format for virtual
machines. Because WebAssembly code is designed to provide portable
low-level instructions that enable applications to be deployed on many
platforms such as the web, it is a natural fit for deploying
applications that are intended to run on ICP. However, most of the
higher-level languages that support compiling to WebAssembly are either
unsafe or complex for developers who want to deliver secure applications
without a long learning curve.</p>
<p>To address the need for correctness without complexity, DFINITY has
designed its own Motoko programming language. Motoko provides a simple
and expressive alternative to other programming languages that is easy
to learn whether you are a new or experienced programmer.</p>
<h2 id="motivation-and-goals">Motivation and goals</h2>
<p>Motoko strives to be a simple and useful language for ICP smart
contracts that uses a familiar syntax that incorporates the actor model.
Motoko offers seamless integration for ICP features and makes the most
out of WebAssembly's present and future functionalities.</p>
<p>Motoko is not, and is not intended to be, the only language for
implementing canister smart contracts. Canister development kits exist
for Rust, TypeScript, Python, and soon Solidity. ICP's goal is to enable
any language to be able to produce canister smart contracts by compiling
the canister source code into WebAssembly.</p>
<p>However, its tailored design means Motoko should be the easiest and
safest language for coding on ICP.</p>
<h2 id="key-design-points">Key design points</h2>
<p>Motoko provides many other developer productivity features. It has
derived inspiration for its design from languages such as Java,
JavaScript, C#, Swift, Pony, ML, and Haskell.</p>
<p>Motoko syntax should be familiar to JavaScript programmers, but
without the quirks of JavaScript.</p>
<p>Motoko is a concurrent, actor-oriented language with convenient
support for concurrency control using async/await and futures. Its core
is a call-by-value, impure functional language with imperative and
object-oriented features.</p>
<p>Motoko is strongly typed and offers option types, records, variants,
generics and subtyping. The type system is structural so that types with
different names but equivalent definition are interchangeable; subtyping
allows values to be used at their precise type but also at any more
general supertype.</p>
<ul>
<li>Motoko is safety-oriented.</li>
<li>Memory management is automated using a garbage collector.</li>
<li>Implicit null values are avoided. Nulls must be handled explicitly
using option types.</li>
<li>The type system cannot be circumvented using unsafe casts.</li>
<li>Arithmetic either uses unbounded integers that cannot overflow, or,
when using bounded integers, employs checked arithmetic that faults on
overflow.</li>
<li>All coercions between unrelated types are explicit.</li>
<li>Implicit promotion of a value to another type can only be achieved
by subtyping, an operation with zero cost.</li>
<li>Motoko's support for concise, compiler-checked pattern matching
encourages good coding style and auditable code.</li>
<li>Error-prone, object-oriented inheritance is not supported.</li>
</ul>
<p>Motoko canisters are compiled, not interpreted, producing small
binaries with good performance.</p>
<h3 id="native-canister-smart-contract-support">Native canister smart
contract support</h3>
<p>Motoko has native support for canister smart contracts, which are
expressed as a Motoko actor. An actor is an autonomous object that fully
encapsulates its state and communicates with other actors only through
asynchronous messages.</p>
<h3 id="code-sequentially-in-direct-style">Code sequentially in direct
style</h3>
<p>On ICP, canisters can communicate with other canisters by sending
asynchronous messages.</p>
<p>Asynchronous programming is hard, so Motoko enables you to author
asynchronous code in much simpler, sequential style. Asynchronous
messages are function calls that return a future, and the
<code>await</code> construct allows you to suspend execution until a
future has completed.</p>
<h3 id="modern-type-system">Modern type system</h3>
<p>Motoko has been designed to be intuitive to those familiar with
JavaScript and other popular languages, but offers modern features such
as sound structural types, generics, variant types, and statically
checked pattern matching.</p>
<h3 id="autogenerated-idl-files">Autogenerated IDL files</h3>
<p>A Motoko actor always presents a typed interface to its clients as a
suite of named functions with argument and future result types.</p>
<p>The Motoko compiler and IC SDK can emit this interface in a language
neutral format called Candid, so other canisters, browser resident code
and smart phone apps that support Candid can use the actor’s services.
The Motoko compiler can consume and produce Candid files, allowing
Motoko to seamlessly interact with canisters implemented in other
programming languages, provided they also support Candid.</p>
<h3 id="orthogonal-persistence">Orthogonal persistence</h3>
<p>ICP persists the memory and other state information of a canister as
it is executed. Thus the state of a Motoko actor, including its
in-memory data structures, survive indefinitely. Actor state does not
need to be explicitly restored and saved to external storage.</p>
<h3 id="upgrades">Upgrades</h3>
<p>Motoko provides numerous features to help you leverage orthogonal
persistence, including language features that allow you to retain a
canister’s data as you upgrade the code of the canister.</p>
<p>For example, Motoko lets you declare certain variables as
<code>stable</code>. The values of <code>stable</code> variables are
automatically preserved across canister upgrades.</p>
<p>Once upgraded, the new interface is compatible with the previous one,
meaning existing clients referencing the canister will continue to work,
but new clients will be able to exploit its upgraded functionality. For
more complex changes of any kind, Motoko provides a safe way of
user-defined <a
href="../canister-maintenance/compatibility.md#explicit-migration">explicit
migration</a>.</p>
<h2 id="getting-started">Getting started</h2>
<p>Get started with Motoko by <a href="dev-env.md">setting up your
developer environment</a> and creating a simple <a
href="quickstart.md">Hello, world!</a> program.</p>
<img src="https://github.com/user-attachments/assets/844ca364-4d71-42b3-aaec-4a6c3509ee2e" alt="Logo" width="150" height="150" />
</body>
</html>
