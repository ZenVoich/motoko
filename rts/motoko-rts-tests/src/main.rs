#![feature(proc_macro_hygiene)]

// #![no_std]
//#![feature(start)]
#![feature(core_intrinsics)]

mod print;

// // mod bigint;
// // mod bitrel;
// // mod continuation_table;
// // mod crc32;
// // mod gc;
// // mod leb128;
// // mod memory;
// // mod principal_id;
// // mod stream;
// // mod text;
// // mod utf8;

// use motoko_rts::types::{read64, write64, Bytes};

// fn main() {
//     // if std::mem::size_of::<usize>() != 4 {
//     //     println!("Motoko RTS only works on 32-bit architectures");
//     //     std::process::exit(1);
//     // }

//     unsafe {
//         //println!("Test Main");
//         println("Motoko RTS tests running...");
//         // test_read_write_64_bit();
//         // bigint::test();
//         // bitrel::test();
//         // continuation_table::test();
//         // crc32::test();
//         // gc::test();
//         // leb128::test();
//         // principal_id::test();
//         // stream::test();
//         // text::test();
//         // utf8::test();
//     }
// }

// fn test_read_write_64_bit() {
//     println!("Testing 64-bit read-write");
//     const TEST_VALUE: u64 = 0x1234_5678_9abc_def0;
//     let mut lower = 0u32;
//     let mut upper = 0u32;
//     write64(&mut lower, &mut upper, TEST_VALUE);
//     assert_eq!(lower, 0x9abc_def0);
//     assert_eq!(upper, 0x1234_5678);
//     assert_eq!(read64(lower, upper), TEST_VALUE);
// }

// Called by the RTS to panic
#[no_mangle]
extern "C" fn rts_trap(ptr: *const u8, len: Bytes<u32>) -> ! {
    let msg = unsafe { std::slice::from_raw_parts(ptr, len.as_usize()) };
    match core::str::from_utf8(msg) {
        Err(err) => panic!(
            "rts_trap_with called with non-UTF8 string (error={:?}, string={:?})",
            err, msg
        ),
        Ok(str) => panic!("rts_trap_with: {:?}", str),
    }
}

// // Called by RTS BigInt functions to panic. Normally generated by the compiler
// #[no_mangle]
// extern "C" fn bigint_trap() -> ! {
//     panic!("bigint_trap called");
// }

// Called by the RTS for debug prints
#[no_mangle]
unsafe extern "C" fn print_ptr(ptr: usize, len: u32) {
    let str: &[u8] = core::slice::from_raw_parts(ptr as *const u8, len as usize);
    println!("[RTS] {}", &String::from_utf8_lossy(str));

    // let bytes = core::slice::from_raw_parts(ptr as *const u8, len as usize);
    // let text = String::from_utf8_lossy(bytes);
    // println(&text);
}

// #![no_std]
// #![feature(start)]
// #![feature(core_intrinsics)]

use core::intrinsics::abort;

use motoko_rts::types::Bytes;

// #[start]
// pub fn main(_length: isize, _arguments: *const *const u8) -> isize {
//     unsafe {
//         println("Motoko RTS tests running...");
//         0
//     }
// }

pub fn main() {
    unsafe {
        println!("SECOND TEST RUST WASM64");
        println!("MACRO PRINT TEST");
        print!("TEST2");
        motoko_rts::println!(100, "TEST RTS MESSAGE");
        println!("THIRD TEST RUST WASM64");
    }
}

// #[link(wasm_import_module = "wasi_unstable")]
// extern "C" {
//     fn fd_write(fd: i32, iovs: i32, iovs_len: i32, nwritten: i32) -> i32;
// }

// #[repr(C)]
// struct iov {
//     base: i32,
//     len: i32,
// }

#[no_mangle]
pub fn _start() {
    main();
    
    //panic!("TEST");
}

// const BUFFER_LENGTH: usize = 1024;

// static mut NWRITTEN: i32 = 0;
// static mut TEXT_BUFFER: [u8; BUFFER_LENGTH] = [0; BUFFER_LENGTH];
// static mut IOV: iov = iov { base: 0, len: 0 };

// unsafe fn println(text: &str) {
//     let mut length = 0;
//     for character in text.chars() {
//         TEXT_BUFFER[length] = character as u8;
//         length += 1;
//         if length + 1 >= TEXT_BUFFER.len() {
//             break;
//         }
//     }
//     TEXT_BUFFER[length] = '\n' as u8; // necessary for output
//     length += 1;

//     IOV.base = &mut TEXT_BUFFER[0] as *mut u8 as i32;
//     IOV.len = length as i32;

//     let iov_array = &mut IOV as *mut iov;
//     const STDOUT: i32 = 1;
//     const IOV_ARRAY_LENGTH: i32 = 1;
//     let nwritten_ptr = (&mut NWRITTEN) as *mut i32;

//     fd_write(STDOUT, iov_array as i32, IOV_ARRAY_LENGTH, nwritten_ptr as i32);
// }

// pub fn test() {
//     loop {}
// }

// #[panic_handler]
// unsafe fn panic(_info: &core::panic::PanicInfo) -> ! {
//     println("PANIC!");
//     abort();
// }

// #[macro_export]
// macro_rules! println {
//     ($($arg:tt)*) => ({
//         {
//             use core::fmt::Write;
//             let mut buf = [0 as u8; 256];
//             let mut fmt = motoko_rts::print::WriteBuf::new(&mut buf);
//             let _ = write!(&mut fmt, $($arg)*);
//             motoko_rts::print::print(&fmt);
//         }
//     })
// }

// #[macro_export]
// macro_rules! println {
//     ($($arg:tt)*) => ({
//         motoko_rts::println!(BUFFER_LENGTH, $($arg)*);
//     })
// }

// #[macro_export]
// macro_rules! println {
//     ($($arg:tt)*) => ({
//         {
//             let mut output = String::new();
//             motoko_rts::write!(&mut output, $($arg)*).unwrap();
//             println(&output);
//         }
//     })
// }

// #[macro_export]
// macro_rules! println {
//     ($($arg:tt)*) => ({
//         {
//             use core::fmt::Write;
//             let mut buf = [0 as u8; 256];
//             let mut fmt = WriteBuf::new(&mut buf);
//             write!(&mut fmt, $($arg)*).unwrap();
//             fmt.print();
//         }
//     })
// }

// #[macro_export]
// macro_rules! print {
//     ($($arg:tt)*) => ({
//         println!($($arg)*);
//     })
// }

// pub struct WriteBuf<'a> {
//     buffer: &'a mut [u8],
//     length: usize,
// }

// impl<'a> WriteBuf<'a> {
//     pub(crate) fn new(buffer: &'a mut [u8]) -> Self {
//         Self { buffer, length: 0 }
//     }

//     pub(crate) fn reset(&mut self) {
//         self.length = 0;
//     }

//     pub(crate) unsafe fn print(&self) {
//         let data = &self.buffer[0] as *const u8;
//         let bytes = core::slice::from_raw_parts(data, self.length as usize);
//         let text = String::from_utf8_lossy(bytes);
//         println(&text);
//     }
// }

// impl<'a> core::fmt::Write for WriteBuf<'a> {
//     fn write_str(&mut self, s: &str) -> core::fmt::Result {
//         let remainder = self.buffer.len() - self.length;
//         let target = &mut self.buffer[self.length..];
//         let bytes = s.as_bytes();
//         let length = core::cmp::min(remainder, bytes.len());
//         (&mut target[..length]).copy_from_slice(&bytes[..length]);
//         self.length += length;
//         Ok(())
//     }
// }
