//! Persistent type compatibility check.
//! Determines whether the a new actor type is compatible with the existing persistent state.
//!
//! This is determined by focusing on the stable actor fields (comprised in `stable_actor`).
//!
//! To be compatible, all the fields of an actor must be compatible to the previous state.
//! A field is compatible if at least one of the condition holds:
//! * The field is declared flexible, i.e. not stable, in the previous or new actor version.
//! * The previous actor does not contain a field with that same name.
//! * The field type is compatible to the type of the equally named field in the previous version.
//!
//! A new type is compatible to a previous type if
//! * the types are identical
//! * The new type is sub-type of the previous field.
//!
//! The existing sub-type relations are also memory-compatible at the runtime system level:
//! * Nat can be interpreted as Int.
//! * If record fields are dropped in a declaration, old records with more fields can still
//!   be accessed.
//!   -> However, redundant old fields should be removed in the future, e.g. by the GC.
//! * Variant options can be added, without invalidating the existing variant tags.
//!
//! Binary format of the stable type encoding, generated by the Motoko compiler backend, `persistence.ml`.
//!
//! All composed non-primitive types are encoded in a table without defined order, except for the
//! first entry.
//! The first type in the table denotes the stable sub-type of the actor, ie. all its stable field
//! declarations, without option wrapping.
//!
//! Non-primitive types are referred to by a positive index according to the type table.
//! Primitive types are encoded by predefined negative indices.
//! All numbers (type indices etc.) are encoded as little endian i32.
//!
//! ```
//! <type_table> ::= length:i32 (<type>)^length
//! <type> ::= <object>
//! <object> ::= 1l field_list
//! <field_list> ::= length:i32 (<field>)^length
//! <field> ::= label_hash:i32 type_index:i32
//! ```
//!
//! Predefined primitive type indices
//!
//! Type    | Index
//! ------- | --------
//! Nat     | -1l

use crate::{
    mem_utils::memzero_bytes,
    memory::{alloc_blob, Memory},
    types::{size_of, Bytes, Value},
};

const OBJECT_ENCODING_TAG: i32 = 1;

const ACTOR_TYPE_INDEX: i32 = 0;

const OBJECT_ENCODING_HEADER: usize = 2; // object_tag field_list_length
const FIELD_ENCODING_LENGTH: usize = 2; // label_hash type_index

struct EncodedData {
    words: *const i32,
    size: usize,
}

impl EncodedData {
    pub fn new(words: *const i32, size: usize) -> EncodedData {
        EncodedData { words, size }
    }

    unsafe fn read(&self, offset: usize) -> i32 {
        assert!(offset < self.size);
        let location = self.words.add(offset);
        *location
    }

    unsafe fn sub_view(&self, offset: usize, length: usize) -> EncodedData {
        assert!(offset + length <= self.size);
        EncodedData {
            words: self.words.add(offset),
            size: length,
        }
    }
}

struct TypeTable {
    data: EncodedData,
}

impl TypeTable {
    unsafe fn new(value: Value) -> TypeTable {
        let blob = value.as_blob();
        assert_eq!(blob.len().as_usize() % size_of::<i32>().as_usize(), 0);
        let words = blob.payload_const() as *const i32;
        let size = blob.len().as_usize() / size_of::<i32>().as_usize();
        let data = EncodedData::new(words, size);
        TypeTable { data }
    }

    unsafe fn count_types(&self) -> usize {
        let count = self.data.read(0);
        assert!(count >= 0);
        count as usize
    }

    unsafe fn get_type(&self, type_index: i32) -> Type {
        assert!(type_index <= self.count_types() as i32);
        assert_eq!(type_index, 0); // TODO: Skip over other types
        let start = 1;
        let tag = self.data.read(start);
        assert_eq!(tag, OBJECT_ENCODING_TAG);
        let count_fields = self.data.read(start + 1);
        assert!(count_fields >= 0);
        let size = OBJECT_ENCODING_HEADER + count_fields as usize * FIELD_ENCODING_LENGTH;
        let type_view = self.data.sub_view(start, size);
        let object_type = ObjectType::new(type_view);
        Type::Object(object_type)
    }

    unsafe fn get_actor(&self) -> ObjectType {
        match self.get_type(ACTOR_TYPE_INDEX) {
            Type::Object(object_type) => object_type,
            // _ => panic!("Invalid stable type encoding")
        }
    }
}

enum Type {
    Object(ObjectType),
}

struct ObjectType {
    data: EncodedData,
}

impl ObjectType {
    unsafe fn new(data: EncodedData) -> ObjectType {
        assert_eq!(data.read(0), OBJECT_ENCODING_TAG);
        ObjectType { data }
    }

    unsafe fn count_fields(&self) -> usize {
        assert_eq!(self.data.read(0), OBJECT_ENCODING_TAG);
        let count = self.data.read(1);
        assert!(count >= 0);
        count as usize
    }

    unsafe fn get_field(&self, field_index: usize) -> Field {
        let field_offset = OBJECT_ENCODING_HEADER + field_index * FIELD_ENCODING_LENGTH;
        let label_hash = self.data.read(field_offset);
        let type_index = self.data.read(field_offset + 1);
        Field {
            label_hash,
            type_index,
        }
    }

    unsafe fn find_field(&self, label_hash: i32) -> Option<Field> {
        for field_index in 0..self.count_fields() {
            let field = self.get_field(field_index);
            if field.label_hash == label_hash {
                return Some(field);
            }
        }
        None
    }
}

struct Field {
    label_hash: i32,
    type_index: i32,
}

/// Cache for remembering previous type compatibility checks.
/// Necessary to avoid infinite loops on type recursion.
/// Helpful to optimize repeated checks.
struct TypeCheckCache {
    bitmap: *mut u8,
    count_new_types: usize,
    count_old_types: usize,
}

impl TypeCheckCache {
    pub unsafe fn new<M: Memory>(
        mem: &mut M,
        new_types: &TypeTable,
        old_types: &TypeTable,
    ) -> TypeCheckCache {
        let count_new_types = new_types.count_types();
        let count_old_types = old_types.count_types();
        let bit_size = count_new_types * count_old_types;
        let byte_size = Bytes((bit_size as u32 + u8::BITS - 1) / u8::BITS);
        let blob = alloc_blob(mem, byte_size);
        let bitmap = blob.as_blob_mut().payload_addr();
        memzero_bytes(bitmap as usize, byte_size);
        TypeCheckCache {
            bitmap,
            count_new_types,
            count_old_types,
        }
    }

    pub unsafe fn visited(&self, new_type_index: i32, old_type_index: i32) -> bool {
        let (byte, bit_index) = self.position(new_type_index, old_type_index);
        (*byte >> bit_index) & 0b1 != 0
    }

    pub unsafe fn visit(&mut self, new_type_index: i32, old_type_index: i32) {
        let (byte, bit_index) = self.position(new_type_index, old_type_index);
        *byte |= 0b1 << bit_index;
    }

    unsafe fn position(&self, new_type_index: i32, old_type_index: i32) -> (*mut u8, usize) {
        assert!(new_type_index >= 0);
        assert!(old_type_index >= 0);
        assert!((new_type_index as usize) < self.count_new_types);
        assert!((old_type_index as usize) < self.count_old_types);
        let index = new_type_index as usize * self.count_old_types + old_type_index as usize;
        let byte_index = index / u8::BITS as usize;
        let bit_index = index % u8::BITS as usize;
        let byte = self.bitmap.add(byte_index);
        (byte, bit_index)
    }
}

unsafe fn type_compatible(
    cache: &mut TypeCheckCache,
    _new_type_table: &TypeTable,
    new_type_index: i32,
    _old_type_table: &TypeTable,
    old_type_index: i32,
) -> bool {
    if new_type_index >= 0 && old_type_index >= 0 {
        if cache.visited(new_type_index, old_type_index) {
            return true;
        }
        cache.visit(new_type_index, old_type_index);

        // TODO: Implement check
        unimplemented!()
    } else if new_type_index < 0 {
        new_type_index == old_type_index
    } else {
        false
    }
}

unsafe fn compatible_actor_fields<M: Memory>(
    mem: &mut M,
    new_type_table: TypeTable,
    old_type_table: TypeTable,
) -> bool {
    let mut cache = TypeCheckCache::new(mem, &new_type_table, &old_type_table);
    let new_actor = new_type_table.get_actor();
    let old_actor = old_type_table.get_actor();
    for new_field_index in 0..new_actor.count_fields() {
        let new_field = new_actor.get_field(new_field_index);
        match old_actor.find_field(new_field.label_hash) {
            Some(old_field) => {
                if !type_compatible(
                    &mut cache,
                    &new_type_table,
                    new_field.type_index,
                    &old_type_table,
                    old_field.type_index,
                ) {
                    return false;
                }
            }
            None => {}
        }
    }
    true
}

// TODO: Unit test this funcionality

/// Test whether the new stable type complies with the existing old stable type.
/// Both arguments point to blobs encoding a stable actor type.
pub unsafe fn memory_compatible<M: Memory>(mem: &mut M, old_type: Value, new_type: Value) -> bool {
    let new_type_table = TypeTable::new(new_type);
    let old_type_table = TypeTable::new(old_type);
    compatible_actor_fields(mem, new_type_table, old_type_table)
}
