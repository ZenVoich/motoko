//! Persistent type compatibility check.
//! Determines whether the a new actor type is compatible with the existing persistent state.
//!
//! This is determined by focusing on the stable actor fields (comprised in `stable_actor`).
//!
//! To be compatible, all the fields of an actor must be compatible to the previous state.
//! A field is compatible if at least one of the condition holds:
//! * The field is declared flexible, i.e. not stable, in the previous or new actor version.
//! * The previous actor does not contain a field with that same name.
//! * The field type is compatible to the type of the equally named field in the previous version.
//!
//! A new type is compatible to a previous type if
//! * the types are identical
//! * The new type is sub-type of the previous field.
//!
//! The existing sub-type relations are also memory-compatible at the runtime system level:
//! * Nat can be interpreted as Int.
//! * If record fields are dropped in a declaration, old records with more fields can still
//!   be accessed.
//!   -> However, redundant old fields should be removed in the future, e.g. by the GC.
//! * Variant options can be added, without invalidating the existing variant tags.
//!
//! Binary format of the stable type encoding, generated by the Motoko compiler backend, `persistence.ml`.
//!
//! All composed non-primitive types are encoded in a table without defined order, except for the
//! first entry.
//! The first type in the table denotes the stable sub-type of the actor, ie. all its stable field
//! declarations, without option wrapping.
//!
//! Non-primitive types are referred to by a positive index according to the type table.
//! Primitive types are encoded by predefined negative indices.
//! All numbers (type indices etc.) are encoded as little endian i32.
//!
//! ```
//! <type_table> ::= length:i32 (<type>)^length
//! <type> ::= <object>
//! <object> ::= 1l field_list
//! <field_list> ::= length:i32 (<field>)^length
//! <field> ::= label_hash:i32 type_index:i32
//! ```
//!
//! Predefined primitive type indices
//!
//! Type    | Index
//! ------- | --------
//! Nat     | -1l

use crate::types::{size_of, Value};

const OBJECT_ENCODING_TAG: i32 = 1;

const ACTOR_TYPE_INDEX: i32 = 0;

const OBJECT_ENCODING_HEADER: usize = 2; // object_tag field_list_length
const FIELD_ENCODING_LENGTH: usize = 2; // label_hash type_index

struct EncodedData {
    words: *const i32,
    size: usize,
}

impl EncodedData {
    pub fn new(words: *const i32, size: usize) -> EncodedData {
        EncodedData { words, size }
    }

    unsafe fn read(&self, offset: usize) -> i32 {
        assert!(offset < self.size);
        let location = self.words.add(offset);
        *location
    }

    unsafe fn sub_view(&self, offset: usize, length: usize) -> EncodedData {
        assert!(offset + length <= self.size);
        EncodedData {
            words: self.words.add(offset),
            size: length,
        }
    }
}

struct TypeTable {
    data: EncodedData,
}

impl TypeTable {
    unsafe fn new(value: Value) -> TypeTable {
        let blob = value.as_blob();
        assert_eq!(blob.len().as_usize() % size_of::<i32>().as_usize(), 0);
        let words = blob.payload_const() as *const i32;
        let size = blob.len().as_usize() / size_of::<i32>().as_usize();
        let data = EncodedData::new(words, size);
        TypeTable { data }
    }

    unsafe fn count_types(&self) -> usize {
        let count = self.data.read(0);
        assert!(count >= 0);
        count as usize
    }

    unsafe fn get_type(&self, type_index: i32) -> Type {
        assert!(type_index <= self.count_types() as i32);
        assert_eq!(type_index, 0); // TODO: Skip over other types
        let start = 1;
        let tag = self.data.read(start);
        assert_eq!(tag, OBJECT_ENCODING_TAG);
        let count_fields = self.data.read(start + 1);
        assert!(count_fields >= 0);
        let size = OBJECT_ENCODING_HEADER + count_fields as usize * FIELD_ENCODING_LENGTH;
        let type_view = self.data.sub_view(start, size);
        let object_type = ObjectType::new(type_view);
        Type::Object(object_type)
    }

    unsafe fn get_actor(&self) -> ObjectType {
        match self.get_type(ACTOR_TYPE_INDEX) {
            Type::Object(object_type) => object_type,
            // _ => panic!("Invalid stable type encoding")
        }
    }
}

enum Type {
    Object(ObjectType),
}

struct ObjectType {
    data: EncodedData,
}

impl ObjectType {
    unsafe fn new(data: EncodedData) -> ObjectType {
        assert_eq!(data.read(0), OBJECT_ENCODING_TAG);
        ObjectType { data }
    }

    unsafe fn count_fields(&self) -> usize {
        assert_eq!(self.data.read(0), OBJECT_ENCODING_TAG);
        let count = self.data.read(1);
        assert!(count >= 0);
        count as usize
    }

    unsafe fn get_field(&self, field_index: usize) -> Field {
        let field_offset = OBJECT_ENCODING_HEADER + field_index * FIELD_ENCODING_LENGTH;
        let label_hash = self.data.read(field_offset);
        let type_index = self.data.read(field_offset + 1);
        Field {
            label_hash,
            type_index,
        }
    }

    unsafe fn find_field(&self, label_hash: i32) -> Option<Field> {
        for field_index in 0..self.count_fields() {
            let field = self.get_field(field_index);
            if field.label_hash == label_hash {
                return Some(field);
            }
        }
        None
    }
}

struct Field {
    label_hash: i32,
    type_index: i32,
}

fn type_compatible(
    _new_type_table: &TypeTable,
    new_type_index: i32,
    _old_type_table: &TypeTable,
    old_type_index: i32,
) -> bool {
    unsafe {
        println!(100, "COMPATIBLE {new_type_index} {old_type_index}");
    }
    if new_type_index < 0 {
        new_type_index == old_type_index
    } else {
        false
    }
}

// TODO: Unit test this funcionality

// TODO: Use visited table for handling recursion and avoiding repeated type checks.

/// Test whether the new stable type complies with the existing old stable type.
/// Both arguments point to blobs encoding a stable actor type.
pub unsafe fn memory_compatible(old_type: Value, new_type: Value) -> bool {
    let new_type_table = TypeTable::new(new_type);
    let old_type_table = TypeTable::new(old_type);
    let new_actor = new_type_table.get_actor();
    let old_actor = old_type_table.get_actor();
    for new_field_index in 0..new_actor.count_fields() {
        let new_field = new_actor.get_field(new_field_index);
        println!(100, "CHECK ACTOR FIELD {} {}", new_field.label_hash, old_actor.find_field(new_field.label_hash).is_some());
        match old_actor.find_field(new_field.label_hash) {
            Some(old_field) => {
                if !type_compatible(
                    &new_type_table,
                    new_field.type_index,
                    &old_type_table,
                    old_field.type_index,
                ) {
                    return false;
                }
            }
            None => {}
        }
    }
    true

    // // TODO: Implement supported sub-type relations

    // // Identical types
    // let old_descriptor = old_type.as_blob();
    // let new_descriptor = new_type.as_blob();
    // let old_size = old_descriptor.len().as_usize();
    // let new_size = new_descriptor.len().as_usize();
    // if old_size != new_size {
    //     return false;
    // }

    // assert_eq!(old_size, new_size);
    // let comparison = memcmp(
    //     old_descriptor.payload_const() as *const c_void,
    //     new_descriptor.payload_const() as *const c_void,
    //     old_size,
    // );

    // comparison == 0
}

// pub unsafe fn print_type_descriptor(value: Value) {
//     let descriptor = value.as_blob();
//     let size = descriptor.len().as_usize();
//     println!(100, "OUTPUT {}", size);
//     for index in 0..size {
//         println!(100, "{:#x} ", *descriptor.payload_const().add(index));
//     }
//     println!(100, "---");
// }
